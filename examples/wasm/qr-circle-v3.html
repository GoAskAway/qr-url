<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Circle Debug Tool</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: monospace;
            background: #f5f5f5;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
            background: white;
        }

        #left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: auto;
        }

        #right-panel {
            width: 350px;
            padding: 20px;
            background: #fafafa;
            border-left: 1px solid #ddd;
            overflow-y: auto;
        }

        h1 {
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        #svg-container {
            border: 1px solid #ddd;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        svg {
            display: block;
        }

        .controls {
            margin: 0;
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        input[type="range"] {
            width: 100%;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .slider-label span {
            font-weight: bold;
            color: #2196F3;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid #ffc107;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin: 20px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #2196F3;
        }

        @media print {
            body {
                background: white;
                overflow: visible;
            }

            #container {
                display: block;
                height: auto;
            }

            #left-panel {
                padding: 0;
                overflow: visible;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
            }

            #right-panel {
                display: none;
            }

            h1 {
                display: none;
            }

            #svg-container {
                border: none;
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="left-panel">
            <h1>QR Circle Debug Tool - 29Ã—29 Grid</h1>
            <div id="svg-container"></div>
        </div>

        <div id="right-panel">
            <div class="section-title">QR è¯†åˆ«æµ‹è¯•</div>
            <div class="controls">
                <div class="control-group">
                    <button id="test-qr" style="width: 100%; padding: 10px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æµ‹è¯•è¯†åˆ« (Test QR)
                    </button>
                </div>
                <div class="control-group" style="display: flex; align-items: center; gap: 10px;">
                    <div id="qr-status-light" style="width: 24px; height: 24px; border-radius: 50%; background: #999; border: 2px solid #666; box-shadow: inset 0 0 5px rgba(0,0,0,0.3);"></div>
                    <span id="qr-status-text" style="font-size: 14px; color: #666;">æœªæµ‹è¯•</span>
                </div>
                <div id="qr-result" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="section-title">å›¾å±‚æ§åˆ¶ï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰</div>
            <div class="controls">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-4-decoration">
                        <span style="color: #FFFFFF; font-weight: bold; text-shadow: 0 0 2px #000;">4ï¸âƒ£ ä¿®é¥°ç½‘æ ¼å±‚</span>
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-3-algorithm">
                        <span style="color: #00FF00; font-weight: bold;">3ï¸âƒ£ ç®—æ³•æ‰‡ç¯å±‚</span>
                    </label>
                </div>
                <div class="control-group">
                    <label style="color: #607D8B; font-weight: bold;">
                        2.5 è¾…åŠ©è°ƒè¯•å±‚ï¼ˆé®ç½©ä¹‹ä¸Šï¼‰
                    </label>
                    <div style="margin-left: 24px; margin-top: 5px;">
                        <div style="margin-bottom: 3px;">
                            <label><input type="checkbox" id="show-grid" checked> ç½‘æ ¼çº¿</label>
                        </div>
                        <div style="margin-bottom: 3px;">
                            <label><input type="checkbox" id="show-circles" checked> åœ†ç¯ï¼ˆæ¯0.5å•ä½ï¼‰</label>
                        </div>
                        <div style="margin-bottom: 3px;">
                            <label><input type="checkbox" id="show-radials" checked> æ”¾å°„çº¿ï¼ˆæ¯3Â°ï¼‰</label>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-2-mask" checked>
                        <span style="color: #888888; font-weight: bold;">2ï¸âƒ£ åŠŸèƒ½æ€§é®ç½©å±‚ï¼ˆç•™ç™½ï¼‰</span>
                    </label>
                    <div style="margin-left: 24px; margin-top: 5px;">
                        <input type="file" id="upload-mask" accept=".svg" style="font-size: 11px; width: 100%;">
                        <button id="clear-mask" style="margin-top: 5px; padding: 4px 8px; font-size: 11px; cursor: pointer; background: #f44336; color: white; border: none; border-radius: 3px;">
                            æ¸…é™¤é®ç½©
                        </button>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-1-original" checked>
                        <span style="color: #FF0000; font-weight: bold;">1ï¸âƒ£ åŸå§‹ QR å±‚ï¼ˆæœ€åº•å±‚ï¼‰</span>
                    </label>
                </div>
            </div>

            <div class="section-title">è¦†ç›–ç‡æ£€æµ‹</div>
            <div class="controls">
                <div class="control-group">
                    <button id="run-detection" style="width: 100%; padding: 10px; cursor: pointer; background: #FF5722; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)
                    </button>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-errors">
                        <span style="color: #FF0000; font-weight: bold;">æ˜¾ç¤ºé”™è¯¯æ ‡è®°</span>
                    </label>
                </div>
                <div id="detection-stats" style="margin-top: 10px; padding: 10px; background: #ffebee; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="section-title">è‡ªåŠ¨ç¯æ‰‡å½¢è½¬æ¢ç®—æ³•</div>
            <div class="controls">
                <div class="control-group">
                    <button id="run-algorithm" style="width: 100%; padding: 10px; cursor: pointer; background: #9C27B0; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        è¿è¡Œç®—æ³• (Run Algorithm)
                    </button>
                </div>
                <div class="control-group">
                    <button id="debug-sector" style="width: 100%; padding: 8px; cursor: pointer; background: #607D8B; color: white; border: none; border-radius: 4px; font-size: 12px;">
                        è°ƒè¯•æ‰‡ç¯ (Debug Sector)
                    </button>
                </div>
                <div id="algorithm-stats" style="margin-top: 10px; padding: 10px; background: #f3e5f5; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="info">
                <strong>QR ç ä¿¡æ¯ï¼š</strong><br>
                â€¢ ç‰ˆæœ¬ï¼šv3 (29Ã—29)ï¼Œä¸­å¿ƒ (14.5, 14.5)<br>
                â€¢ å†…å®¹ï¼šHTTPS://LETS.GO/LXPB$2PI-W6JBZS$BL6<br>
                â€¢ ç¼–ç ï¼šALPHANUMERIC (å¤§å†™)<br>
                â€¢ å®¹é”™ï¼šH çº§åˆ« (30%)<br>
                <br>
                <strong>å›¾å±‚æ¶æ„ï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰ï¼š</strong><br>
                â€¢ 1ï¸âƒ£ åŸå§‹ QR å±‚ï¼šçº¢è‰²+ç™½è‰²èƒŒæ™¯<br>
                â€¢ 2ï¸âƒ£ åŠŸèƒ½æ€§é®ç½©å±‚ï¼šç™½è‰²ç•™ç™½åŒºåŸŸ<br>
                â€¢ 2.5 è¾…åŠ©è°ƒè¯•å±‚ï¼šç½‘æ ¼çº¿ã€åœ†ç¯ã€æ”¾å°„çº¿ï¼ˆé®ç½©ä¹‹ä¸Šï¼‰<br>
                â€¢ 3ï¸âƒ£ ç®—æ³•æ‰‡ç¯å±‚ï¼šç»¿è‰²æ‰‡ç¯å›¾æ¡ˆ<br>
                â€¢ 4ï¸âƒ£ ä¿®é¥°ç½‘æ ¼å±‚ï¼šç™½è‰²ç¯å½¢è£…é¥°<br>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script>
        // QR Code v3 parameters
        const moduleCount = 29;
        const center = { x: moduleCount / 2, y: moduleCount / 2 }; // (14.5, 14.5)

        // Calculate outer circle radius (diagonal distance from center)
        const outerRadius = Math.sqrt(2) * moduleCount / 2; // â‰ˆ 20.506

        // Set margin to fit the outer circle perfectly
        // margin = outerRadius - moduleCount/2
        const margin = outerRadius - moduleCount / 2; // â‰ˆ 6.006

        // Calculate viewBox dimensions (should match outer circle diameter)
        const viewBoxSize = moduleCount + 2 * margin; // â‰ˆ 41.01

        // Calculate cellSize to fit screen (assuming ~900px available space)
        const cellSize = 21; // SVGå•ä½ (optimized for outer circle fit)
        const svgSize = viewBoxSize * cellSize; // â‰ˆ 861px

        // Create SVG
        const svgContainer = document.getElementById('svg-container');
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgSize);
        svg.setAttribute('height', svgSize);
        // ViewBox fits the outer circle exactly
        const initialViewBox = {
            x: -margin,
            y: -margin,
            width: viewBoxSize,
            height: viewBoxSize
        };
        svg.setAttribute('viewBox', `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
        svgContainer.appendChild(svg);

        // Zoom limits: 50% to 1000% (viewBox width: 50.4 to 2.52)
        const minViewBoxWidth = initialViewBox.width / 10;  // 1000% zoom
        const maxViewBoxWidth = initialViewBox.width * 2;   // 50% zoom

        // Generate real QR code using qrcode-generator library
        function generateQRPattern() {
            // Create QR code with type 3 (29x29), error correction level H (30%)
            const qr = qrcode(3, 'H');
            // Explicitly specify ALPHANUMERIC mode
            // ALPHANUMERIC only supports: 0-9, A-Z, space, $ % * + - . / :
            // 35 chars Ã— 5.5 bits = 193 bits, fits in v3+H (208 bits data capacity)
            qr.addData('HTTPS://LETS.GO/LXPB$2PI-W6JBZS$BL6', 'Alphanumeric');
            qr.make();

            const count = qr.getModuleCount();
            const modules = Array(count).fill(null).map(() => Array(count).fill(false));

            for (let row = 0; row < count; row++) {
                for (let col = 0; col < count; col++) {
                    modules[row][col] = qr.isDark(row, col);
                }
            }

            return modules;
        }

        const qrModules = generateQRPattern();

        // Fine-grained cell state management (grid + radials + rings)
        const STORAGE_KEY_BASE = 'qr-circle-base';
        let baseModuleState = {}; // { "row,col": true/false } - base QR pattern

        // Algorithm state (automatic conversion result)
        // Store sector colors directly, without grid subdivision
        let sectorColors = {}; // { "radial:idx|ring:idx": true/false } - sector-based colors
        let algorithmState = {}; // Legacy: for comparison with manual edits
        let algorithmStats = null; // Algorithm execution statistics

        const RADIAL_COUNT = 120; // 120 radial lines (every 3Â°)
        const RING_INTERVAL = 0.5; // Ring every 0.5 units
        const maxRadius = Math.sqrt(2) * moduleCount / 2;
        const RING_COUNT = Math.ceil(maxRadius / RING_INTERVAL);

        // Initialize base state
        function initializeBaseState() {
            baseModuleState = {};
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    baseModuleState[`${row},${col}`] = qrModules[row][col];
                }
            }
            localStorage.setItem(STORAGE_KEY_BASE, JSON.stringify(baseModuleState));
        }

        // Always initialize with freshly generated QR code
        // (ignore localStorage to ensure we use the latest QR data)
        initializeBaseState();

        // Create global defs for clipPaths
        const globalDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        globalDefs.setAttribute('id', 'global-defs');
        svg.appendChild(globalDefs);

        // Module layer (for finder patterns, alignment patterns, etc.)
        const moduleLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        moduleLayer.setAttribute('id', 'module-layer');
        svg.appendChild(moduleLayer);

        // === Layer architecture (bottom to top) ===
        // Layer 1: Original QR layer (red + white background, fully opaque)
        const originalDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        originalDisplayLayer.setAttribute('id', 'layer-1-original');
        originalDisplayLayer.setAttribute('opacity', '1'); // Fully opaque
        svg.appendChild(originalDisplayLayer);

        // Layer 2: Functional mask layer (white, fully opaque to hide data)
        const maskLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        maskLayer.setAttribute('id', 'layer-2-mask');
        maskLayer.setAttribute('opacity', '1'); // Fully opaque
        svg.appendChild(maskLayer);

        // Layer 2.5: Auxiliary debug layer (above mask, below algorithm)
        const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        gridLayer.setAttribute('id', 'grid-layer');
        svg.appendChild(gridLayer);

        const circleLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        circleLayer.setAttribute('id', 'circle-layer');
        svg.appendChild(circleLayer);

        const radialLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        radialLayer.setAttribute('id', 'radial-layer');
        svg.appendChild(radialLayer);

        // Layer 3: Algorithm annular layer (green, fully opaque)
        const algorithmDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        algorithmDisplayLayer.setAttribute('id', 'layer-3-algorithm');
        algorithmDisplayLayer.setAttribute('opacity', '1'); // Fully opaque
        svg.appendChild(algorithmDisplayLayer);

        // Layer 4: White ring decoration layer (on top of algorithm layer)
        const whiteRingLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        whiteRingLayer.setAttribute('id', 'white-ring-layer');
        svg.appendChild(whiteRingLayer);

        // Error detection layer: highlight insufficient coverage (highest z-index)
        const errorLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        errorLayer.setAttribute('id', 'error-layer');
        svg.appendChild(errorLayer);

        // Legacy algorithm layer (kept for compatibility)
        const algorithmLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        algorithmLayer.setAttribute('id', 'algorithm-layer');
        algorithmLayer.setAttribute('opacity', '0.7'); // Semi-transparent for comparison
        svg.appendChild(algorithmLayer);

        // Draw grid
        function drawGrid() {
            gridLayer.innerHTML = '';

            // Vertical lines
            for (let i = 0; i <= moduleCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', i);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', i);
                line.setAttribute('y2', moduleCount);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                gridLayer.appendChild(line);
            }

            // Horizontal lines
            for (let i = 0; i <= moduleCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', i);
                line.setAttribute('x2', moduleCount);
                line.setAttribute('y2', i);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                gridLayer.appendChild(line);
            }
        }

        // Draw circles (every 0.5 unit)
        function drawCircles() {
            circleLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2; // Diagonal distance

            for (let r = 0.5; r <= maxRadius; r += 0.5) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', center.x);
                circle.setAttribute('cy', center.y);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ff6b6b');
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.setAttribute('opacity', '0.5');
                circleLayer.appendChild(circle);
            }
        }

        // Draw radial lines (every 3 degrees, 120 total)
        function drawRadialLines() {
            radialLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2;

            for (let degree = 0; degree < 360; degree += 3) { // Every 3 degrees
                const angle = degree * Math.PI / 180; // Convert to radians
                const x2 = center.x + maxRadius * Math.cos(angle);
                const y2 = center.y + maxRadius * Math.sin(angle);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', center.x);
                line.setAttribute('y1', center.y);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#4ecdc4');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                line.setAttribute('opacity', '0.5');
                radialLayer.appendChild(line);
            }

            // Draw center point
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', center.x);
            centerDot.setAttribute('cy', center.y);
            centerDot.setAttribute('r', '0.1');
            centerDot.setAttribute('fill', '#4ecdc4');
            radialLayer.appendChild(centerDot);
        }

        // Draw white rings (overlay circles with white stroke)
        function drawWhiteRings() {
            whiteRingLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2; // Diagonal distance

            for (let r = 0.5; r <= maxRadius; r += 0.5) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', center.x);
                circle.setAttribute('cy', center.y);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.setAttribute('opacity', '0.8');
                whiteRingLayer.appendChild(circle);
            }
        }

        // ========== ALGORITHM: Automatic Sector-Ring Conversion ==========

        // Create a complete sector (annular segment) path - NO grid clipping
        function createCompleteSectorPath(radialIndex, ringIndex) {
            const angle1 = radialIndex * 3 * Math.PI / 180;
            const angle2 = (radialIndex + 1) * 3 * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Calculate four vertices
            const x1_inner = center.x + r1 * Math.cos(angle1);
            const y1_inner = center.y + r1 * Math.sin(angle1);
            const x2_inner = center.x + r1 * Math.cos(angle2);
            const y2_inner = center.y + r1 * Math.sin(angle2);
            const x1_outer = center.x + r2 * Math.cos(angle1);
            const y1_outer = center.y + r2 * Math.sin(angle1);
            const x2_outer = center.x + r2 * Math.cos(angle2);
            const y2_outer = center.y + r2 * Math.sin(angle2);

            // Determine if arc is large (> 180 degrees)
            const largeArc = (angle2 - angle1) > Math.PI ? 1 : 0;

            // Build annular sector path
            let pathData = `M ${x1_inner} ${y1_inner}`;  // Start at inner arc, angle1
            pathData += ` A ${r1} ${r1} 0 ${largeArc} 1 ${x2_inner} ${y2_inner}`;  // Inner arc to angle2
            pathData += ` L ${x2_outer} ${y2_outer}`;  // Line to outer arc
            pathData += ` A ${r2} ${r2} 0 ${largeArc} 0 ${x1_outer} ${y1_outer}`;  // Outer arc back to angle1
            pathData += ` Z`;  // Close path

            return pathData;
        }

        // Check if a point is inside an annular sector (ring segment)
        function isPointInSector(px, py, radialIndex, ringIndex) {
            const dx = px - center.x;
            const dy = py - center.y;
            const radius = Math.sqrt(dx * dx + dy * dy);

            // Check radius range
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            if (radius < r1 || radius > r2) return false;

            // Check angle range
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            const a1 = radialIndex * 3;
            const a2 = (radialIndex + 1) * 3;

            return angle >= a1 && angle < a2;
        }

        // Calculate overlap area between a sector and a grid cell using Monte Carlo sampling
        function calculateOverlapArea(gridRow, gridCol, radialIndex, ringIndex, samples = 100) {
            let hits = 0;

            // Sample points in the grid cell
            for (let i = 0; i < samples; i++) {
                for (let j = 0; j < samples; j++) {
                    const px = gridCol + (i + 0.5) / samples;
                    const py = gridRow + (j + 0.5) / samples;

                    if (isPointInSector(px, py, radialIndex, ringIndex)) {
                        hits++;
                    }
                }
            }

            const cellArea = 1.0; // Unit cell area
            return (hits / (samples * samples)) * cellArea;
        }

        // Find all sectors that overlap with a grid cell
        function findOverlappingSectors(gridRow, gridCol) {
            const overlaps = [];
            const maxRadius = Math.sqrt(2) * moduleCount / 2;
            const maxRing = Math.ceil(maxRadius / RING_INTERVAL);

            // Check cell center to determine which radials/rings might overlap
            const cellCenterX = gridCol + 0.5;
            const cellCenterY = gridRow + 0.5;
            const dx = cellCenterX - center.x;
            const dy = cellCenterY - center.y;
            const cellRadius = Math.sqrt(dx * dx + dy * dy);
            let cellAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (cellAngle < 0) cellAngle += 360;

            // Search nearby rings (Â±1 from cell center ring)
            const centerRing = Math.floor(cellRadius / RING_INTERVAL);
            for (let ring = Math.max(0, centerRing - 1); ring <= Math.min(maxRing, centerRing + 2); ring++) {
                // Search nearby radials (Â±2 from cell center radial)
                const centerRadial = Math.floor(cellAngle / 3);
                for (let radial = centerRadial - 2; radial <= centerRadial + 2; radial++) {
                    const normalizedRadial = ((radial % 120) + 120) % 120;

                    const overlapArea = calculateOverlapArea(gridRow, gridCol, normalizedRadial, ring, 50);
                    if (overlapArea > 0.001) { // Threshold to avoid floating point noise
                        const cellId = `grid:${gridRow},${gridCol}|radial:${normalizedRadial}|ring:${ring}`;
                        overlaps.push({
                            cellId,
                            radialIndex: normalizedRadial,
                            ringIndex: ring,
                            overlapArea
                        });
                    }
                }
            }

            return overlaps;
        }

        // Find all grid cells that overlap with a sector
        function findOverlappingGridCells(radialIndex, ringIndex) {
            const overlaps = [];

            // Determine bounding box of the sector
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const a1 = radialIndex * 3 * Math.PI / 180;
            const a2 = (radialIndex + 1) * 3 * Math.PI / 180;

            // Calculate sector bounding box
            const points = [
                { x: center.x + r1 * Math.cos(a1), y: center.y + r1 * Math.sin(a1) },
                { x: center.x + r1 * Math.cos(a2), y: center.y + r1 * Math.sin(a2) },
                { x: center.x + r2 * Math.cos(a1), y: center.y + r2 * Math.sin(a1) },
                { x: center.x + r2 * Math.cos(a2), y: center.y + r2 * Math.sin(a2) }
            ];

            const minRow = Math.floor(Math.min(...points.map(p => p.y))) - 1;
            const maxRow = Math.ceil(Math.max(...points.map(p => p.y))) + 1;
            const minCol = Math.floor(Math.min(...points.map(p => p.x))) - 1;
            const maxCol = Math.ceil(Math.max(...points.map(p => p.x))) + 1;

            // Check each grid cell in bounding box
            for (let row = minRow; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    const overlapArea = calculateOverlapArea(row, col, radialIndex, ringIndex, 50);
                    if (overlapArea > 0.001) {
                        overlaps.push({
                            gridRow: row,
                            gridCol: col,
                            overlapArea
                        });
                    }
                }
            }

            return overlaps;
        }

        // Helper: Check if a module is in finder pattern 7x7 region
        function isInFinderPatternRegion(row, col) {
            // Top-left (0-6, 0-6)
            if (row >= 0 && row <= 6 && col >= 0 && col <= 6) return true;
            // Top-right (0-6, 22-28)
            if (row >= 0 && row <= 6 && col >= 22 && col <= 28) return true;
            // Bottom-left (22-28, 0-6)
            if (row >= 22 && row <= 28 && col >= 0 && col <= 6) return true;
            return false;
        }

        // Helper: Check if a module is in alignment pattern inner 3x3 region
        // Alignment pattern is at (22, 22), 5x5 total, inner 3x3 is (21-23, 21-23)
        function isInAlignmentPatternInner(row, col) {
            return row >= 21 && row <= 23 && col >= 21 && col <= 23;
        }

        // Helper: Check if a module is covered by mask layer
        function isModuleMaskedByLayer(row, col) {
            if (!maskData) return false;

            const moduleX = col + 0.5; // Center of module
            const moduleY = row + 0.5;

            // Check circles
            if (maskData.circles) {
                for (const circle of maskData.circles) {
                    const dx = moduleX - circle.cx;
                    const dy = moduleY - circle.cy;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < circle.r) {
                        return true; // Module is masked by this circle
                    }
                }
            }

            // Check rectangles
            if (maskData.rects) {
                for (const rect of maskData.rects) {
                    if (moduleX >= rect.x && moduleX < rect.x + rect.w &&
                        moduleY >= rect.y && moduleY < rect.y + rect.h) {
                        return true; // Module is masked by this rectangle
                    }
                }
            }

            return false;
        }

        // SIMPLIFIED ALGORITHM: Calculate sector color based on maximum overlap area
        function calculateSectorColor_Simplified(radialIndex, ringIndex, debug = false) {
            // Find all grid cells that overlap with this sector
            const overlappingGrids = findOverlappingGridCells(radialIndex, ringIndex);

            if (overlappingGrids.length === 0) {
                return false; // Default to white if no overlap
            }

            // Collect colors and areas
            const gridColors = new Set();
            const colorAreas = { black: 0, white: 0 };
            const gridDetails = [];
            let skippedCount = 0;

            for (const overlap of overlappingGrids) {
                const { gridRow, gridCol, overlapArea } = overlap;

                // Skip finder pattern 7x7 regions
                if (isInFinderPatternRegion(gridRow, gridCol)) {
                    skippedCount++;
                    if (debug) {
                        gridDetails.push({
                            grid: `${gridRow},${gridCol}`,
                            color: 'SKIPPED (Finder)',
                            area: overlapArea.toFixed(4)
                        });
                    }
                    continue;
                }

                // Skip alignment pattern inner 3x3 region
                if (isInAlignmentPatternInner(gridRow, gridCol)) {
                    skippedCount++;
                    if (debug) {
                        gridDetails.push({
                            grid: `${gridRow},${gridCol}`,
                            color: 'SKIPPED (Alignment Inner)',
                            area: overlapArea.toFixed(4)
                        });
                    }
                    continue;
                }

                // Check if module is masked (treat as white if masked)
                const isMasked = isModuleMaskedByLayer(gridRow, gridCol);
                const isBlack = isMasked ? false : (baseModuleState[`${gridRow},${gridCol}`] || false);

                gridColors.add(isBlack);

                if (isBlack) {
                    colorAreas.black += overlapArea;
                } else {
                    colorAreas.white += overlapArea;
                }

                if (debug) {
                    gridDetails.push({
                        grid: `${gridRow},${gridCol}`,
                        color: isMasked ? 'white (masked)' : (isBlack ? 'black' : 'white'),
                        area: overlapArea.toFixed(4)
                    });
                }
            }

            // If all grids were skipped, return white
            if (skippedCount === overlappingGrids.length) {
                if (debug) {
                    console.log(`[Sector ${radialIndex},${ringIndex}] All grids skipped (finder/alignment)`);
                }
                return false;
            }

            // Case 1 & 2: All grids have the same color
            const result = gridColors.size === 1
                ? Array.from(gridColors)[0]
                : colorAreas.black > colorAreas.white;

            if (debug) {
                console.log(`[Sector ${radialIndex},${ringIndex}]`, {
                    overlappingGrids: gridDetails,
                    skippedGrids: skippedCount,
                    colorAreas: {
                        black: colorAreas.black.toFixed(4),
                        white: colorAreas.white.toFixed(4)
                    },
                    sameColor: gridColors.size === 1,
                    result: result ? 'BLACK' : 'WHITE'
                });
            }

            return result;
        }

        // Check if a grid cell violates the 25% constraint
        function checkGridConstraint(gridRow, gridCol) {
            const isGridBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
            const gridArea = 1.0;
            const maxChange = gridArea * 0.25;

            const overlappingSectors = findOverlappingSectors(gridRow, gridCol);

            let totalChange = 0;
            for (const sector of overlappingSectors) {
                const sectorColor = algorithmState[sector.cellId];
                if (sectorColor === undefined) continue;

                const overlapArea = sector.overlapArea;

                if (isGridBlack && !sectorColor) {
                    // Grid black, sector white -> subtraction
                    totalChange += overlapArea;
                } else if (!isGridBlack && sectorColor) {
                    // Grid white, sector black -> addition
                    totalChange += overlapArea;
                }
            }

            return {
                violated: totalChange > maxChange,
                totalChange,
                maxChange,
                percentage: (totalChange / gridArea) * 100
            };
        }

        // SIMPLIFIED ALGORITHM: Pure sector-based conversion using Monte Carlo
        async function runConversionAlgorithm() {
            console.log('[Algorithm] ğŸš€ Starting PURE SECTOR-BASED conversion...');
            const startTime = performance.now();

            sectorColors = {};
            algorithmState = {}; // Also populate for comparison
            let sameColorCount = 0;
            let differentColorCount = 0;

            const maxRadius = Math.sqrt(2) * moduleCount / 2;
            const maxRing = Math.ceil(maxRadius / RING_INTERVAL);
            const totalSectors = 120 * maxRing;

            console.log('[Algorithm] Processing sectors (radial Ã— ring)...');
            let processed = 0;

            // Iterate through all sectors (radial, ring) - NO grid subdivision
            for (let ring = 0; ring <= maxRing; ring++) {
                for (let radial = 0; radial < 120; radial++) {
                    // Calculate color for this complete sector
                    const color = calculateSectorColor_Simplified(radial, ring);
                    const sectorId = `radial:${radial}|ring:${ring}`;
                    sectorColors[sectorId] = color;

                    // Also populate algorithmState for comparison with manual edits
                    // (manual edits are grid-subdivided, so we need to map sectors to grids)
                    const overlappingGrids = findOverlappingGridCells(radial, ring);
                    for (const overlap of overlappingGrids) {
                        const cellId = `grid:${overlap.gridRow},${overlap.gridCol}|radial:${radial}|ring:${ring}`;
                        algorithmState[cellId] = color;
                    }

                    // Track statistics
                    const colors = new Set(overlappingGrids.map(g => baseModuleState[`${g.gridRow},${g.gridCol}`] || false));
                    if (colors.size === 1) {
                        sameColorCount++;
                    } else {
                        differentColorCount++;
                    }

                    processed++;
                    if (processed % 200 === 0) {
                        console.log(`[Algorithm] Processed ${processed}/${totalSectors} sectors`);
                    }
                }
            }

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);

            algorithmStats = {
                totalSectors: Object.keys(sectorColors).length,
                sameColorSectors: sameColorCount,
                mixedColorSectors: differentColorCount,
                elapsedSeconds: elapsed
            };

            console.log('[Algorithm] âœ… Completed!', algorithmStats);
            console.log(`[Algorithm] Pure sectors: ${Object.keys(sectorColors).length}`);
            console.log(`[Algorithm] Grid-mapped cells: ${Object.keys(algorithmState).length}`);
            return algorithmStats;
        }


        // Fix a violated grid cell by flipping sectors with least impact
        function fixViolatedCell(gridRow, gridCol) {
            const isGridBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
            const overlappingSectors = findOverlappingSectors(gridRow, gridCol);

            // Find sectors to flip
            const candidates = [];
            for (const sector of overlappingSectors) {
                const sectorColor = algorithmState[sector.cellId];
                if (sectorColor === undefined) continue;

                // If grid is black and sector is white (contributing to violation), consider flipping to black
                // If grid is white and sector is black (contributing to violation), consider flipping to white
                if ((isGridBlack && !sectorColor) || (!isGridBlack && sectorColor)) {
                    candidates.push({
                        cellId: sector.cellId,
                        overlapArea: sector.overlapArea
                    });
                }
            }

            // Flip the largest overlapping sector (most impact)
            if (candidates.length > 0) {
                candidates.sort((a, b) => b.overlapArea - a.overlapArea);
                const toFlip = candidates[0];
                algorithmState[toFlip.cellId] = !algorithmState[toFlip.cellId];
            }
        }

        // Draw algorithm result - PURE SECTOR SHAPES (no grid clipping)
        function drawAlgorithmResult() {
            algorithmLayer.innerHTML = '';

            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawAlgorithmResult] No sector colors to draw');
                return;
            }

            let drawnCount = 0;

            // Draw complete sectors (annular segments) - NO grid subdivision
            for (const [sectorId, color] of Object.entries(sectorColors)) {
                // Only draw black regions (skip white)
                if (!color) continue;

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path (no clipping)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#00FF00'); // Green (ç®—æ³•ç»“æœ)
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                algorithmLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawAlgorithmResult] Drew', drawnCount, 'complete sectors (pure annular segments)');
        }

        // === NEW: Three independent display functions ===

        // Helper: Draw circular finder pattern on specified layer
        function drawCircularFinderPatternOnLayer(layer, centerX, centerY, color) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `finder-mask-${centerX}-${centerY}-${color}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 3.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black - creates white ring)
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', 2.5);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 1.5);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            layer.appendChild(defs);

            // Draw the outer ring
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 3.5);
            outerRing.setAttribute('fill', color);
            outerRing.setAttribute('mask', `url(#${maskId})`);
            layer.appendChild(outerRing);

            // Draw the center dot
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 1.5);
            centerDot.setAttribute('fill', color);
            layer.appendChild(centerDot);
        }

        // Helper: Draw circular alignment pattern on specified layer (ring pattern)
        // 5x5 pattern: Black(1) - White(1) - Black(1) - White(1) - Black(1)
        // Radii: outer=2.5, middle=1.5, center=0.5
        function drawCircularAlignmentPatternOnLayer(layer, centerX, centerY, color) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `alignment-mask-${centerX}-${centerY}-${color}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white) - radius 2.5
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 2.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black) - radius 1.5, creates white ring
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', 1.5);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white) - radius 0.5, allows center dot to show
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 0.5);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            layer.appendChild(defs);

            // Draw the outer ring with mask
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 2.5);
            outerRing.setAttribute('fill', color);
            outerRing.setAttribute('mask', `url(#${maskId})`);
            layer.appendChild(outerRing);

            // Draw the center dot - radius 0.5
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 0.5);
            centerDot.setAttribute('fill', color);
            layer.appendChild(centerDot);
        }

        // Draw original QR code (rectangular coordinate system, red)
        function drawOriginalDisplay() {
            originalDisplayLayer.innerHTML = '';

            // Define special pattern regions to exclude from rectangular drawing
            const specialPatternModules = new Set();

            // Finder pattern regions (7x7 + separator)
            const finderRegions = [
                { rowMin: 0, rowMax: 8, colMin: 0, colMax: 8 },      // Top-left
                { rowMin: 0, rowMax: 8, colMin: 21, colMax: 29 },    // Top-right
                { rowMin: 21, rowMax: 29, colMin: 0, colMax: 8 }     // Bottom-left
            ];

            finderRegions.forEach(region => {
                for (let row = region.rowMin; row < region.rowMax; row++) {
                    for (let col = region.colMin; col < region.colMax; col++) {
                        if (row < moduleCount && col < moduleCount) {
                            specialPatternModules.add(`${row},${col}`);
                        }
                    }
                }
            });

            // Alignment pattern region (5x5 for QR v3)
            for (let row = 20; row <= 24; row++) {
                for (let col = 20; col <= 24; col++) {
                    specialPatternModules.add(`${row},${col}`);
                }
            }

            // Draw all regular modules (both black and white for opaque background)
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    // Skip special pattern areas
                    if (specialPatternModules.has(`${row},${col}`)) continue;

                    const isBlack = baseModuleState[`${row},${col}`];

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', col);
                    rect.setAttribute('y', row);
                    rect.setAttribute('width', 1);
                    rect.setAttribute('height', 1);
                    rect.setAttribute('fill', isBlack ? '#FF0000' : '#FFFFFF'); // Red for black, white for white
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('shape-rendering', 'crispEdges');

                    originalDisplayLayer.appendChild(rect);
                }
            }

            // Draw circular finder patterns (red color for original QR layer)
            const finderCenters = [
                { x: 3.5, y: 3.5 },      // Top-left
                { x: 25.5, y: 3.5 },     // Top-right
                { x: 3.5, y: 25.5 }      // Bottom-left
            ];
            finderCenters.forEach(center => {
                drawCircularFinderPatternOnLayer(originalDisplayLayer, center.x, center.y, '#FF0000');
            });

            // Draw circular alignment pattern (red color for original QR layer)
            drawCircularAlignmentPatternOnLayer(originalDisplayLayer, 22.5, 22.5, '#FF0000');
        }


        // Draw algorithm sectors (annular coordinate system, green)
        function drawAlgorithmDisplay() {
            algorithmDisplayLayer.innerHTML = '';

            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawAlgorithmDisplay] No sector colors to draw');
                return;
            }

            let drawnCount = 0;

            for (const [sectorId, color] of Object.entries(sectorColors)) {
                if (!color) continue; // Only draw black regions

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#00FF00'); // Green
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                algorithmDisplayLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawAlgorithmDisplay] Drew', drawnCount, 'algorithm sectors');
        }

        // === Coverage detection functions (OPTIMIZED) ===

        // Calculate which sector (radial, ring) a point belongs to - O(1)
        function getSectorIndicesForPoint(x, y) {
            const dx = x - center.x;
            const dy = y - center.y;
            const r = Math.sqrt(dx * dx + dy * dy);

            // Calculate angle in degrees [0, 360)
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            // Calculate sector indices directly
            const radialIndex = Math.floor(angle / 3); // 3 degrees per sector
            const ringIndex = Math.floor(r / RING_INTERVAL);

            return { radialIndex, ringIndex };
        }

        // Check if a point is covered - O(1) with Set lookup
        function isPointCovered(x, y, algorithmSectorsSet) {
            const { radialIndex, ringIndex } = getSectorIndicesForPoint(x, y);
            const sectorId = `radial:${radialIndex}|ring:${ringIndex}`;

            // Fast Set lookup instead of array traversal
            if (algorithmSectorsSet && algorithmSectorsSet.has(sectorId)) {
                return true;
            }

            return false;
        }


        // Pre-compute algorithm sectors Set - called once
        function getAlgorithmSectorsSet() {
            const blackSectors = new Set();
            for (const [sectorId, color] of Object.entries(sectorColors)) {
                if (color) { // Only black sectors
                    blackSectors.add(sectorId);
                }
            }
            return blackSectors;
        }

        // Detect coverage errors - OPTIMIZED VERSION
        function detectCoverageErrors(checkAlgorithm = true) {
            console.log('[detectCoverageErrors] Starting OPTIMIZED detection...');
            const startTime = performance.now();
            const errors = [];
            const sampleSize = 10; // Reduced from 20 to 10 (100 samples instead of 400)

            // MAJOR OPTIMIZATION: Pre-compute sector Sets once!
            const algorithmSectorsSet = checkAlgorithm ? getAlgorithmSectorsSet() : null;

            console.log(`[detectCoverageErrors] Pre-computed algorithm sectors: ${algorithmSectorsSet ? algorithmSectorsSet.size : 0}`);

            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    const isBlack = baseModuleState[`${row},${col}`];
                    if (!isBlack) continue; // Only check black modules

                    let coveredCount = 0;
                    const totalCount = sampleSize * sampleSize;

                    // Sample points within module rectangle [col, col+1] Ã— [row, row+1]
                    for (let i = 0; i < sampleSize; i++) {
                        for (let j = 0; j < sampleSize; j++) {
                            const x = col + (i + 0.5) / sampleSize;
                            const y = row + (j + 0.5) / sampleSize;

                            // O(1) lookup instead of O(n) traversal!
                            if (isPointCovered(x, y, algorithmSectorsSet)) {
                                coveredCount++;
                            }
                        }
                    }

                    const coverage = coveredCount / totalCount;
                    if (coverage < 0.75) { // Coverage < 75% (error > 25%)
                        errors.push({ row, col, coverage });
                    }
                }
            }

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);
            console.log(`[detectCoverageErrors] âœ… Found ${errors.length} errors in ${elapsed}s`);
            return errors;
        }

        // Draw error markers on error layer
        function drawErrorMarkers(errors) {
            errorLayer.innerHTML = '';

            for (const error of errors) {
                const { row, col, coverage } = error;

                // Draw a thick red border around the module
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', col);
                rect.setAttribute('y', row);
                rect.setAttribute('width', 1);
                rect.setAttribute('height', 1);
                rect.setAttribute('fill', 'none');
                rect.setAttribute('stroke', '#FF0000'); // Red
                rect.setAttribute('stroke-width', '0.08');
                rect.setAttribute('opacity', '0.9');

                errorLayer.appendChild(rect);

                // Add text label showing coverage percentage
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', col + 0.5);
                text.setAttribute('y', row + 0.5);
                text.setAttribute('font-size', '0.25');
                text.setAttribute('fill', '#FF0000');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.textContent = Math.round(coverage * 100) + '%';

                errorLayer.appendChild(text);
            }

            console.log(`[drawErrorMarkers] Drew ${errors.length} error markers`);
        }

        // Check if position is in Finder Pattern
        function isInFinderPattern(row, col) {
            // Top-left (0-6, 0-6)
            if (row < 7 && col < 7) return 'top-left';
            // Top-right (0-6, 14-20)
            if (row < 7 && col >= 14) return 'top-right';
            // Bottom-left (14-20, 0-6)
            if (row >= 14 && col < 7) return 'bottom-left';
            return null;
        }

        // Draw circular finder patterns
        function drawCircularFinderPattern(centerX, centerY) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `finder-mask-${centerX}-${centerY}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 3.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black - creates white ring)
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', 2.5);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 1.5);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            moduleLayer.appendChild(defs);

            // Draw the outer ring (use yellow for visibility)
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 3.5);
            outerRing.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            outerRing.setAttribute('mask', `url(#${maskId})`);
            moduleLayer.appendChild(outerRing);

            // Draw the center dot (use yellow for visibility)
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 1.5);
            centerDot.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            moduleLayer.appendChild(centerDot);
        }

        // Draw circular alignment pattern (5x5 pattern for QR v3)
        function drawCircularAlignmentPattern(centerX, centerY) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `alignment-mask-${centerX}-${centerY}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 2.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Inner circle (black - creates white ring)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 1.5);
            innerCircle.setAttribute('fill', 'black');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            moduleLayer.appendChild(defs);

            // Draw the outer ring
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 2.5);
            outerRing.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            outerRing.setAttribute('mask', `url(#${maskId})`);
            moduleLayer.appendChild(outerRing);

            // Draw the center dot
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 1.5);
            centerDot.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            moduleLayer.appendChild(centerDot);
        }

        // Draw QR modules
        function drawModules() {
            moduleLayer.innerHTML = '';

            // Track which modules are in special patterns (to skip them)
            const specialPatternModules = new Set();

            // Draw circular finder patterns
            const finderCenters = [
                { x: 3.5, y: 3.5 },      // Top-left
                { x: 25.5, y: 3.5 },     // Top-right
                { x: 3.5, y: 25.5 }      // Bottom-left
            ];

            // Define finder pattern regions (7x7 squares + 1-cell separator)
            const finderRegions = [
                { rowMin: 0, rowMax: 7, colMin: 0, colMax: 7 },      // Top-left (0-6) + separator
                { rowMin: 0, rowMax: 7, colMin: 21, colMax: 28 },    // Top-right (21-27) + separator
                { rowMin: 21, rowMax: 28, colMin: 0, colMax: 7 }     // Bottom-left (21-27) + separator
            ];

            // Draw circular finder patterns
            for (let i = 0; i < finderCenters.length; i++) {
                const center = finderCenters[i];
                const region = finderRegions[i];

                drawCircularFinderPattern(center.x, center.y);

                // Mark modules in this finder pattern region (including separator)
                for (let row = region.rowMin; row < region.rowMax; row++) {
                    for (let col = region.colMin; col < region.colMax; col++) {
                        specialPatternModules.add(`${row},${col}`);
                    }
                }
            }

            // Draw circular alignment pattern (QR v3 has 1 alignment pattern at position 22,22)
            const alignmentCenter = { x: 22.5, y: 22.5 }; // Center at (22, 22), offset by 0.5
            drawCircularAlignmentPattern(alignmentCenter.x, alignmentCenter.y);

            // Mark alignment pattern region (5x5)
            for (let row = 20; row <= 24; row++) {
                for (let col = 20; col <= 24; col++) {
                    specialPatternModules.add(`${row},${col}`);
                }
            }

            // Draw regular modules (excluding special patterns) - base state only
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    if (specialPatternModules.has(`${row},${col}`)) continue;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', col);
                    rect.setAttribute('y', row);
                    rect.setAttribute('width', 1);
                    rect.setAttribute('height', 1);
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('shape-rendering', 'crispEdges');

                    // Fill based on base module state (use red for visibility)
                    if (baseModuleState[`${row},${col}`]) {
                        rect.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
                    } else {
                        rect.setAttribute('fill', 'white');
                    }

                    moduleLayer.appendChild(rect);
                }
            }
        }


        // Create cell using clipPath for precise intersection
        function createCellWithClip(gridRow, gridCol, radialIndex, ringIndex, cellId) {
            const angle1 = radialIndex * 3 * Math.PI / 180;
            const angle2 = (radialIndex + 1) * 3 * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Create annular sector (ring sector) path
            const x1_inner = center.x + r1 * Math.cos(angle1);
            const y1_inner = center.y + r1 * Math.sin(angle1);
            const x2_inner = center.x + r1 * Math.cos(angle2);
            const y2_inner = center.y + r1 * Math.sin(angle2);
            const x1_outer = center.x + r2 * Math.cos(angle1);
            const y1_outer = center.y + r2 * Math.sin(angle1);
            const x2_outer = center.x + r2 * Math.cos(angle2);
            const y2_outer = center.y + r2 * Math.sin(angle2);

            // Determine if arc is large (> 180 degrees)
            const largeArc = (angle2 - angle1) > Math.PI ? 1 : 0;

            // Build sector path
            let sectorPath = `M ${x1_inner} ${y1_inner}`;  // Start at inner arc, angle1
            sectorPath += ` A ${r1} ${r1} 0 ${largeArc} 1 ${x2_inner} ${y2_inner}`;  // Inner arc to angle2
            sectorPath += ` L ${x2_outer} ${y2_outer}`;  // Line to outer arc
            sectorPath += ` A ${r2} ${r2} 0 ${largeArc} 0 ${x1_outer} ${y1_outer}`;  // Outer arc back to angle1
            sectorPath += ` Z`;  // Close path

            // Create clipPath with grid rectangle
            const clipPathId = `clip-${cellId.replace(/:/g, '-').replace(/,/g, '_')}`;
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', clipPathId);

            const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            clipRect.setAttribute('x', gridCol);
            clipRect.setAttribute('y', gridRow);
            clipRect.setAttribute('width', 1);
            clipRect.setAttribute('height', 1);
            clipPath.appendChild(clipRect);

            // Create path with clipPath applied
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', sectorPath);
            path.setAttribute('clip-path', `url(#${clipPathId})`);

            return { path, clipPath };
        }

        // Old function (keep for reference, can be removed later)
        function createCellPath_OLD(gridRow, gridCol, radialIndex, ringIndex) {
            const angle1 = radialIndex * 4 * Math.PI / 180;
            const angle2 = (radialIndex + 1) * 4 * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const gridLeft = gridCol;
            const gridRight = gridCol + 1;
            const gridTop = gridRow;
            const gridBottom = gridRow + 1;

            // Helper: check if point is in grid bounds
            const inGrid = (x, y) => x >= gridLeft && x <= gridRight && y >= gridTop && y <= gridBottom;

            // Helper: clip line segment to grid rectangle
            const clipLineToGrid = (x1, y1, x2, y2) => {
                // Liang-Barsky algorithm for line-rectangle clipping
                let t0 = 0, t1 = 1;
                const dx = x2 - x1;
                const dy = y2 - y1;

                const clipTest = (p, q) => {
                    if (p === 0) return q >= 0;
                    const r = q / p;
                    if (p < 0) {
                        if (r > t1) return false;
                        if (r > t0) t0 = r;
                    } else {
                        if (r < t0) return false;
                        if (r < t1) t1 = r;
                    }
                    return true;
                };

                if (clipTest(-dx, x1 - gridLeft) &&
                    clipTest(dx, gridRight - x1) &&
                    clipTest(-dy, y1 - gridTop) &&
                    clipTest(dy, gridBottom - y1)) {
                    return {
                        x1: x1 + t0 * dx,
                        y1: y1 + t0 * dy,
                        x2: x1 + t1 * dx,
                        y2: y1 + t1 * dy
                    };
                }
                return null;
            };

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathData = '';
            const vertices = [];

            // Calculate radial line segments clipped to grid
            for (let angle of [angle1, angle2]) {
                const maxR = Math.sqrt(2) * moduleCount;
                const x1 = center.x + r1 * Math.cos(angle);
                const y1 = center.y + r1 * Math.sin(angle);
                const x2 = center.x + r2 * Math.cos(angle);
                const y2 = center.y + r2 * Math.sin(angle);

                const clipped = clipLineToGrid(x1, y1, x2, y2);
                if (clipped) {
                    vertices.push({x: clipped.x1, y: clipped.y1, angle, r: r1, type: 'radial'});
                    vertices.push({x: clipped.x2, y: clipped.y2, angle, r: r2, type: 'radial'});
                }
            }

            // Add arc endpoints if they're in grid
            for (let angle of [angle1, angle2]) {
                for (let r of [r1, r2]) {
                    const x = center.x + r * Math.cos(angle);
                    const y = center.y + r * Math.sin(angle);
                    if (inGrid(x, y)) {
                        // Already added by radial lines
                    }
                }
            }

            // Sort vertices by angle
            vertices.sort((a, b) => {
                const angleA = Math.atan2(a.y - center.y, a.x - center.x);
                const angleB = Math.atan2(b.y - center.y, b.x - center.x);
                if (Math.abs(angleA - angleB) < 0.001) {
                    return a.r - b.r; // Same angle, sort by radius
                }
                return angleA - angleB;
            });

            if (vertices.length < 2) return null;

            // Build path with arcs
            pathData = `M ${vertices[0].x} ${vertices[0].y}`;

            for (let i = 0; i < vertices.length; i++) {
                const curr = vertices[i];
                const next = vertices[(i + 1) % vertices.length];

                const currAngle = Math.atan2(curr.y - center.y, curr.x - center.x);
                const nextAngle = Math.atan2(next.y - center.y, next.x - center.x);
                const currR = Math.sqrt(Math.pow(curr.x - center.x, 2) + Math.pow(curr.y - center.y, 2));
                const nextR = Math.sqrt(Math.pow(next.x - center.x, 2) + Math.pow(next.y - center.y, 2));

                // Check if same radius (arc) or same angle (radial line)
                if (Math.abs(currR - nextR) < 0.01) {
                    // Arc segment
                    const largeArc = Math.abs(nextAngle - currAngle) > Math.PI ? 1 : 0;
                    pathData += ` A ${currR} ${currR} 0 ${largeArc} 1 ${next.x} ${next.y}`;
                } else {
                    // Line segment
                    pathData += ` L ${next.x} ${next.y}`;
                }
            }

            pathData += ' Z';
            path.setAttribute('d', pathData);
            return path;
        }

        // Initial draw
        drawGrid();
        drawCircles();
        drawRadialLines();
        drawWhiteRings();
        drawModules();

        // Draw new independent display layers
        drawOriginalDisplay();
        // drawAlgorithmDisplay() will be called after algorithm runs

        // éšè—æ—§çš„è°ƒè¯•å›¾å±‚
        moduleLayer.style.display = 'none';
        algorithmLayer.style.display = 'none';

        // å››å±‚è®¾è®¡çš„åˆå§‹æ˜¾ç¤ºçŠ¶æ€
        // Layer 1: Original QR - é»˜è®¤æ˜¾ç¤º (checked)
        originalDisplayLayer.style.display = 'block';

        // Layer 2: Mask - é»˜è®¤æ˜¾ç¤º (checked)
        maskLayer.style.display = 'block';

        // Layer 3: Algorithm - é»˜è®¤éšè— (unchecked)
        algorithmDisplayLayer.style.display = 'none';

        // Layer 4: Decoration (white rings) - é»˜è®¤éšè— (unchecked)
        whiteRingLayer.style.display = 'none';

        // Error layer
        errorLayer.style.display = 'none';

        // Toggle controls
        document.getElementById('show-grid').addEventListener('change', (e) => {
            gridLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-circles').addEventListener('change', (e) => {
            circleLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-radials').addEventListener('change', (e) => {
            radialLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        // show-modules removed - now using show-original for originalDisplayLayer
        // show-white-rings removed - now using show-layer-4-decoration for whiteRingLayer

        // Layer controls (ä¸‰åŸè‰²å›¾å±‚æ§åˆ¶ - æ§åˆ¶æ–°çš„ç‹¬ç«‹æ˜¾ç¤ºå›¾å±‚)
        // Four-layer visibility controls
        document.getElementById('show-layer-1-original').addEventListener('change', (e) => {
            originalDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-layer-2-mask').addEventListener('change', (e) => {
            maskLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-layer-3-algorithm').addEventListener('change', (e) => {
            algorithmDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-layer-4-decoration').addEventListener('change', (e) => {
            whiteRingLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        // Coverage detection controls
        document.getElementById('show-errors').addEventListener('change', (e) => {
            errorLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('run-detection').addEventListener('click', () => {
            const button = document.getElementById('run-detection');
            const statsDiv = document.getElementById('detection-stats');
            const checkbox = document.getElementById('show-errors');

            button.disabled = true;
            button.textContent = 'æ£€æµ‹ä¸­... (Detecting...)';
            statsDiv.style.display = 'none';

            // Check if algorithm layer is currently displayed
            const checkAlgorithm = algorithmDisplayLayer.style.display !== 'none';

            if (!checkAlgorithm) {
                alert('è¯·å…ˆå‹¾é€‰ç®—æ³•æ‰‡ç¯å›¾å±‚ï¼');
                button.disabled = false;
                button.textContent = 'æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)';
                return;
            }

            // Run detection in next frame to allow UI update
            setTimeout(() => {
                try {
                    const errors = detectCoverageErrors(checkAlgorithm);
                    drawErrorMarkers(errors);

                    // Show stats
                    const totalBlackModules = Object.values(baseModuleState).filter(v => v).length;
                    const errorRate = ((errors.length / totalBlackModules) * 100).toFixed(1);

                    let statsHTML = `
                        <strong>æ£€æµ‹ç»“æœï¼š</strong><br>
                        â€¢ æ€»é»‘è‰²ç ç‚¹ï¼š${totalBlackModules}<br>
                        â€¢ è¦†ç›–ä¸è¶³ï¼ˆ<75%ï¼‰ï¼š${errors.length}<br>
                        â€¢ é”™è¯¯ç‡ï¼š${errorRate}%<br>
                        <br>
                        <strong>æ£€æµ‹èŒƒå›´ï¼š</strong><br>
                        ${checkAlgorithm ? 'âœ“ ç®—æ³•æ‰‡ç¯å±‚<br>' : ''}
                    `;

                    statsDiv.innerHTML = statsHTML;
                    statsDiv.style.display = 'block';

                    // Auto enable error display
                    if (errors.length > 0) {
                        checkbox.checked = true;
                        errorLayer.style.display = 'block';
                    }

                    alert(`æ£€æµ‹å®Œæˆï¼\nå‘ç° ${errors.length} ä¸ªè¦†ç›–ä¸è¶³çš„ç ç‚¹ï¼ˆ<75%ï¼‰\né”™è¯¯ç‡ï¼š${errorRate}%`);
                } catch (error) {
                    console.error('[Detection] Error:', error);
                    alert('æ£€æµ‹å¤±è´¥ï¼š' + error.message);
                } finally {
                    button.disabled = false;
                    button.textContent = 'æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)';
                }
            }, 10);
        });

        // Algorithm controls
        document.getElementById('run-algorithm').addEventListener('click', async () => {
            const button = document.getElementById('run-algorithm');
            const statsDiv = document.getElementById('algorithm-stats');
            const checkbox = document.getElementById('show-algorithm');

            button.disabled = true;
            button.textContent = 'è¿è¡Œä¸­... (Running...)';
            statsDiv.style.display = 'none';

            try {
                const stats = await runConversionAlgorithm();
                drawAlgorithmResult();
                drawAlgorithmDisplay(); // Draw on new independent display layer

                // Show stats
                let statsHTML = `
                    <strong>ç®—æ³•ç»Ÿè®¡ï¼ˆçº¯æ‰‡ç¯ï¼‰ï¼š</strong><br>
                    â€¢ æ€»æ‰‡ç¯æ•°ï¼š${stats.totalSectors}<br>
                    â€¢ å•è‰²æ‰‡ç¯ï¼š${stats.sameColorSectors}<br>
                    â€¢ æ··è‰²æ‰‡ç¯ï¼š${stats.mixedColorSectors}<br>
                    â€¢ è€—æ—¶ï¼š${stats.elapsedSeconds} ç§’<br>
                `;

                statsHTML += `
                    <br>
                    <strong>é¢œè‰²è¯´æ˜ï¼ˆä¸‰åŸè‰²ï¼‰ï¼š</strong><br>
                    â€¢ ğŸ”´ çº¢è‰²ï¼šåŸå§‹æ–¹å½¢ç ç‚¹<br>
                    â€¢ ğŸ”µ è“è‰²ï¼šäººå·¥æ‰‡ç¯å›¾åƒ<br>
                    â€¢ ğŸŸ¢ ç»¿è‰²ï¼šç®—æ³•æ‰‡ç¯å›¾åƒ<br>
                    â€¢ âšª ç™½è‰²ï¼šç•™ç©ºï¼ˆä¸æ˜¾ç¤ºï¼‰
                `;

                statsDiv.innerHTML = statsHTML;
                statsDiv.style.display = 'block';

                // Auto enable algorithm layer display
                document.getElementById('show-layer-3-algorithm').checked = true;
                algorithmDisplayLayer.style.display = 'block';

                alert('ç®—æ³•æ‰§è¡Œå®Œæˆï¼\nè¯·ä½¿ç”¨"å›¾å±‚æ§åˆ¶"å¤é€‰æ¡†æŸ¥çœ‹ä¸åŒå›¾å±‚ï¼š\n1ï¸âƒ£ åŸå§‹ QR å±‚\n2ï¸âƒ£ åŠŸèƒ½æ€§é®ç½©å±‚\n3ï¸âƒ£ ç®—æ³•æ‰‡ç¯å±‚\n4ï¸âƒ£ ä¿®é¥°ç½‘æ ¼å±‚');
            } catch (error) {
                console.error('[Algorithm] Error:', error);
                alert('ç®—æ³•æ‰§è¡Œå¤±è´¥ï¼š' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'è¿è¡Œç®—æ³• (Run Algorithm)';
            }
        });

        // Debug sector button
        document.getElementById('debug-sector').addEventListener('click', () => {
            const radial = parseInt(prompt('è¾“å…¥ radial index (0-119):', '30'));
            const ring = parseInt(prompt('è¾“å…¥ ring index (0-30):', '5'));

            if (isNaN(radial) || isNaN(ring)) {
                alert('æ— æ•ˆçš„è¾“å…¥');
                return;
            }

            console.log('========================================');
            console.log(`ğŸ” è°ƒè¯•æ‰‡ç¯: radial=${radial}, ring=${ring}`);
            console.log('========================================');

            // Call with debug flag
            const color = calculateSectorColor_Simplified(radial, ring, true);

            // Check algorithm result
            const algoEdits = [];
            for (const [cellId, state] of Object.entries(algorithmState)) {
                if (cellId.includes(`radial:${radial}|ring:${ring}`)) {
                    algoEdits.push({ cellId, state });
                }
            }

            console.log('ğŸ¤– ç®—æ³•ç»“æœ:', algoEdits.length > 0 ? algoEdits : 'æ— ');
            console.log('========================================');

            alert(`è°ƒè¯•å®Œæˆï¼\nè¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºã€‚\n\næ‰‡ç¯é¢œè‰²: ${color ? 'é»‘è‰²' : 'ç™½è‰²'}\nç®—æ³•ç»“æœ: ${algoEdits.length} ä¸ª`);
        });

        // ========== Functional Mask Layer Management ==========
        const STORAGE_KEY_MASK = 'qr-circle-mask';
        let maskData = null; // { circles: [], rects: [] }

        // Load mask from localStorage
        function loadMaskData() {
            const saved = localStorage.getItem(STORAGE_KEY_MASK);
            if (saved) {
                try {
                    maskData = JSON.parse(saved);
                    renderMask();
                    console.log('[Mask] Loaded from localStorage:', maskData);
                } catch (e) {
                    console.error('[Mask] Failed to load:', e);
                }
            }
        }

        // Save mask to localStorage
        function saveMaskData() {
            if (maskData) {
                localStorage.setItem(STORAGE_KEY_MASK, JSON.stringify(maskData));
                console.log('[Mask] Saved to localStorage');
            }
        }

        // Render mask layer (white/blank areas to hide underlying QR data)
        function renderMask() {
            maskLayer.innerHTML = '';
            if (!maskData) return;

            // Render circles (white fill to mask/hide data)
            maskData.circles?.forEach(({ cx, cy, r }) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', cx);
                circle.setAttribute('cy', cy);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', '#FFFFFF'); // White to mask underlying data
                circle.setAttribute('stroke', 'none'); // No border
                circle.setAttribute('shape-rendering', 'crispEdges'); // Pixel-perfect alignment
                circle.setAttribute('opacity', '1');
                maskLayer.appendChild(circle);
            });

            // Render rectangles (white fill to mask/hide data)
            maskData.rects?.forEach(({ x, y, w, h }) => {
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', x);
                rect.setAttribute('y', y);
                rect.setAttribute('width', w);
                rect.setAttribute('height', h);
                rect.setAttribute('fill', '#FFFFFF'); // White to mask underlying data
                rect.setAttribute('stroke', 'none'); // No border
                rect.setAttribute('shape-rendering', 'crispEdges'); // Pixel-perfect alignment
                rect.setAttribute('opacity', '1');
                maskLayer.appendChild(rect);
            });

            console.log(`[Mask] Rendered ${maskData.circles?.length || 0} circles and ${maskData.rects?.length || 0} rects`);
        }

        // Parse SVG mask file
        function parseSVGMask(svgText) {
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
            const circles = [];
            const rects = [];

            // Extract circles
            svgDoc.querySelectorAll('circle').forEach(circle => {
                const cx = parseFloat(circle.getAttribute('cx') || 0);
                const cy = parseFloat(circle.getAttribute('cy') || 0);
                const r = parseFloat(circle.getAttribute('r') || 0);
                circles.push({ cx, cy, r });
            });

            // Extract rectangles
            svgDoc.querySelectorAll('rect').forEach(rect => {
                const x = parseFloat(rect.getAttribute('x') || 0);
                const y = parseFloat(rect.getAttribute('y') || 0);
                const w = parseFloat(rect.getAttribute('width') || 1);
                const h = parseFloat(rect.getAttribute('height') || 1);
                rects.push({ x, y, w, h });
            });

            return { circles, rects };
        }

        // Upload mask file
        document.getElementById('upload-mask').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (evt) => {
                try {
                    const svgText = evt.target.result;
                    maskData = parseSVGMask(svgText);
                    saveMaskData();
                    renderMask();

                    // Auto enable mask layer
                    document.getElementById('show-layer-2-mask').checked = true;
                    maskLayer.style.display = 'block';

                    alert(`é®ç½©å·²ä¸Šä¼ ï¼\nåœ†å½¢: ${maskData.circles.length} ä¸ª\nçŸ©å½¢: ${maskData.rects.length} ä¸ª`);
                } catch (error) {
                    console.error('[Mask] Upload error:', error);
                    alert('ä¸Šä¼ å¤±è´¥ï¼š' + error.message);
                }
            };
            reader.readAsText(file);
        });

        // Clear mask
        document.getElementById('clear-mask').addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦æ¸…é™¤é®ç½©å—ï¼Ÿ')) {
                maskData = null;
                maskLayer.innerHTML = '';
                localStorage.removeItem(STORAGE_KEY_MASK);
                document.getElementById('upload-mask').value = '';
                console.log('[Mask] Cleared');
                alert('é®ç½©å·²æ¸…é™¤');
            }
        });

        // Load mask on init
        loadMaskData();

        // Mouse wheel zoom (zoom centered on cursor, limited to 50%-200%)
    </script>
</body>
</html>
