<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Circle Debug Tool</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: monospace;
            background: #f5f5f5;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
            background: white;
        }

        #left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: auto;
        }

        #right-panel {
            width: 350px;
            padding: 20px;
            background: #fafafa;
            border-left: 1px solid #ddd;
            overflow-y: auto;
        }

        h1 {
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        #svg-container {
            border: 1px solid #ddd;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        svg {
            display: block;
        }

        .controls {
            margin: 0;
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        input[type="range"] {
            width: 100%;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .slider-label span {
            font-weight: bold;
            color: #2196F3;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid #ffc107;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin: 20px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #2196F3;
        }

        @media print {
            body {
                background: white;
                overflow: visible;
            }

            #container {
                display: block;
                height: auto;
            }

            #left-panel {
                padding: 0;
                overflow: visible;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
            }

            #right-panel {
                display: none;
            }

            h1 {
                display: none;
            }

            #svg-container {
                border: none;
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="left-panel">
            <h1>QR Circle Debug Tool - 29Ã—29 Grid</h1>
            <div id="svg-container"></div>
        </div>

        <div id="right-panel">
            <div class="section-title">QR è¯†åˆ«æµ‹è¯•</div>
            <div class="controls">
                <div class="control-group">
                    <button id="test-qr" style="width: 100%; padding: 10px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æµ‹è¯•è¯†åˆ« (Test QR)
                    </button>
                </div>
                <div class="control-group" style="display: flex; align-items: center; gap: 10px;">
                    <div id="qr-status-light" style="width: 24px; height: 24px; border-radius: 50%; background: #999; border: 2px solid #666; box-shadow: inset 0 0 5px rgba(0,0,0,0.3);"></div>
                    <span id="qr-status-text" style="font-size: 14px; color: #666;">æœªæµ‹è¯•</span>
                </div>
                <div id="qr-result" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="section-title">å›¾å±‚æ§åˆ¶ï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰</div>
            <div class="controls">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-4-decoration">
                        <span style="color: #FFFFFF; font-weight: bold; text-shadow: 0 0 2px #000;">4ï¸âƒ£ ä¿®é¥°ç½‘æ ¼å±‚</span>
                    </label>
                    <div style="margin-left: 24px; margin-top: 5px;">
                        <label>
                            <input type="checkbox" id="toggle-dark-background">
                            <span style="color: #999;">æ·±è‰²èƒŒæ™¯ï¼ˆæŸ¥çœ‹ç™½è‰²ç¯ï¼‰</span>
                        </label>
                        <div style="margin-top: 8px;">
                            <label style="display: block; margin-bottom: 3px;">
                                <span style="color: #999;">ç™½è‰²ç¯çº¿å®½: <span id="white-ring-width-value">1.0</span></span>
                            </label>
                            <input type="range" id="white-ring-width" min="0.5" max="3.0" step="0.1" value="1.0" style="width: 100%;">
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-3-algorithm">
                        <span style="color: #00FF00; font-weight: bold;">3ï¸âƒ£ ç®—æ³•æ‰‡ç¯å±‚</span>
                    </label>
                    <div style="margin-left: 24px; margin-top: 5px;">
                        <label>
                            <input type="checkbox" id="toggle-edge-extension">
                            <span style="color: #88FF88;">åº”ç”¨è¾¹ç¼˜å»¶ä¼¸</span>
                        </label>
                        <br>
                        <label>
                            <input type="checkbox" id="toggle-coverage-optimization">
                            <span style="color: #FFAA66;">è¦†ç›–ç‡ä¼˜åŒ–</span>
                        </label>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-2.5-auxiliary" checked>
                        <span style="color: #607D8B; font-weight: bold;">2.5 è¾…åŠ©è°ƒè¯•å±‚ï¼ˆé®ç½©ä¹‹ä¸Šï¼‰</span>
                    </label>
                    <div style="margin-left: 24px; margin-top: 5px;">
                        <div style="margin-bottom: 3px;">
                            <label><input type="checkbox" id="show-grid" checked> ç½‘æ ¼çº¿</label>
                        </div>
                        <div style="margin-bottom: 3px;">
                            <label><input type="checkbox" id="show-circles" checked> åœ†ç¯ï¼ˆæ¯0.5å•ä½ï¼‰</label>
                        </div>
                        <div style="margin-bottom: 3px;">
                            <label><input type="checkbox" id="show-radials" checked> æ”¾å°„çº¿ï¼ˆæ¯3Â°ï¼‰</label>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-layer-1-original" checked>
                        <span style="color: #FF0000; font-weight: bold;">1ï¸âƒ£ åŸå§‹ QR å±‚ï¼ˆæœ€åº•å±‚ï¼‰</span>
                    </label>
                </div>
            </div>

            <div class="section-title">å®šä½ç‚¹å‚æ•°</div>
            <div class="controls">
                <div class="control-group">
                    <label style="display: block; margin-bottom: 3px;">
                        <span style="color: #aaa;">ä¸»å®šä½ç‚¹å¤–ç¯åŠå¾„: <span id="finder-outer-radius-value">3.5</span></span>
                    </label>
                    <input type="range" id="finder-outer-radius" min="2.5" max="4.5" step="0.1" value="3.5" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="display: block; margin-bottom: 3px;">
                        <span style="color: #aaa;">ä¸»å®šä½ç‚¹ç¯å®½åº¦: <span id="finder-ring-width-value">1.0</span></span>
                    </label>
                    <input type="range" id="finder-ring-width" min="0.3" max="2.0" step="0.1" value="1.0" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="display: block; margin-bottom: 3px;">
                        <span style="color: #aaa;">ä¸»å®šä½ç‚¹ä¸­å¿ƒåœ†åŠå¾„: <span id="finder-center-radius-value">1.5</span></span>
                    </label>
                    <input type="range" id="finder-center-radius" min="0.5" max="2.5" step="0.1" value="1.5" style="width: 100%;">
                </div>
                <div class="control-group">
                    <label style="display: block; margin-bottom: 3px;">
                        <span style="color: #aaa;">è¾…åŠ©å®šä½ç‚¹ä¸­å¿ƒåœ†åŠå¾„: <span id="alignment-center-radius-value">0.5</span></span>
                    </label>
                    <input type="range" id="alignment-center-radius" min="0.2" max="1.5" step="0.1" value="0.5" style="width: 100%;">
                </div>
            </div>

            <div class="section-title">è¦†ç›–ç‡æ£€æµ‹</div>
            <div class="controls">
                <div class="control-group">
                    <button id="run-detection" style="width: 100%; padding: 10px; cursor: pointer; background: #FF5722; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)
                    </button>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-errors">
                        <span style="color: #FF0000; font-weight: bold;">æ˜¾ç¤ºé”™è¯¯æ ‡è®°</span>
                    </label>
                </div>
                <div id="detection-stats" style="margin-top: 10px; padding: 10px; background: #ffebee; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="section-title">è‡ªåŠ¨ç¯æ‰‡å½¢è½¬æ¢ç®—æ³•</div>
            <div class="controls">
                <div class="control-group">
                    <button id="run-algorithm" style="width: 100%; padding: 10px; cursor: pointer; background: #9C27B0; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        è¿è¡Œç®—æ³• (Run Algorithm)
                    </button>
                </div>
                <div class="control-group">
                    <button id="debug-sector" style="width: 100%; padding: 8px; cursor: pointer; background: #607D8B; color: white; border: none; border-radius: 4px; font-size: 12px;">
                        è°ƒè¯•æ‰‡ç¯ (Debug Sector)
                    </button>
                </div>
                <div class="control-group">
                    <button id="download-qr" style="width: 100%; padding: 8px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 12px; margin-top: 5px;">
                        ğŸ“¥ ä¸‹è½½çº¯é»‘ç™½ QR ç 
                    </button>
                </div>
                <div id="algorithm-stats" style="margin-top: 10px; padding: 10px; background: #f3e5f5; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="info">
                <strong>QR ç ä¿¡æ¯ï¼š</strong><br>
                â€¢ ç‰ˆæœ¬ï¼šv3 (29Ã—29)ï¼Œä¸­å¿ƒ (14.5, 14.5)<br>
                â€¢ å†…å®¹ï¼šHTTPS://LETS.GO/LXPB$2PI-W6JBZS$BL6<br>
                â€¢ ç¼–ç ï¼šALPHANUMERIC (å¤§å†™)<br>
                â€¢ å®¹é”™ï¼šH çº§åˆ« (30%)<br>
                <br>
                <strong>å›¾å±‚æ¶æ„ï¼ˆè‡ªä¸‹è€Œä¸Šï¼‰ï¼š</strong><br>
                â€¢ 1ï¸âƒ£ åŸå§‹ QR å±‚ï¼šçº¢è‰²+ç™½è‰²èƒŒæ™¯<br>
                â€¢ 2ï¸âƒ£ è¾…åŠ©è°ƒè¯•å±‚ï¼šç½‘æ ¼çº¿ã€åœ†ç¯ã€æ”¾å°„çº¿<br>
                â€¢ 3ï¸âƒ£ ç®—æ³•æ‰‡ç¯å±‚ï¼šç»¿è‰²æ‰‡ç¯å›¾æ¡ˆ<br>
                â€¢ 4ï¸âƒ£ ä¿®é¥°ç½‘æ ¼å±‚ï¼šç™½è‰²ç¯å½¢è£…é¥°<br>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script>
        // QR Code v3 parameters
        const moduleCount = 29;
        const center = { x: moduleCount / 2, y: moduleCount / 2 }; // (14.5, 14.5)

        // Calculate outer circle radius (diagonal distance from center)
        const outerRadius = Math.sqrt(2) * moduleCount / 2; // â‰ˆ 20.506

        // Set margin to fit the outer circle perfectly
        // margin = outerRadius - moduleCount/2
        const margin = outerRadius - moduleCount / 2; // â‰ˆ 6.006

        // Calculate viewBox dimensions (should match outer circle diameter)
        const viewBoxSize = moduleCount + 2 * margin; // â‰ˆ 41.01

        // Calculate cellSize to fit screen (assuming ~900px available space)
        const cellSize = 21; // SVGå•ä½ (optimized for outer circle fit)
        const svgSize = viewBoxSize * cellSize; // â‰ˆ 861px

        // Create SVG
        const svgContainer = document.getElementById('svg-container');
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgSize);
        svg.setAttribute('height', svgSize);
        // ViewBox fits the outer circle exactly
        const initialViewBox = {
            x: -margin,
            y: -margin,
            width: viewBoxSize,
            height: viewBoxSize
        };
        svg.setAttribute('viewBox', `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
        svgContainer.appendChild(svg);

        // Zoom limits: 50% to 1000% (viewBox width: 50.4 to 2.52)
        const minViewBoxWidth = initialViewBox.width / 10;  // 1000% zoom
        const maxViewBoxWidth = initialViewBox.width * 2;   // 50% zoom

        // Generate real QR code using qrcode-generator library
        function generateQRPattern() {
            // Create QR code with type 3 (29x29), error correction level H (30%)
            const qr = qrcode(3, 'H');
            // Explicitly specify ALPHANUMERIC mode
            // ALPHANUMERIC only supports: 0-9, A-Z, space, $ % * + - . / :
            // 35 chars Ã— 5.5 bits = 193 bits, fits in v3+H (208 bits data capacity)
            qr.addData('HTTPS://LETS.GO/LXPB$2PI-W6JBZS$BL6', 'Alphanumeric');
            qr.make();

            const count = qr.getModuleCount();
            const modules = Array(count).fill(null).map(() => Array(count).fill(false));

            for (let row = 0; row < count; row++) {
                for (let col = 0; col < count; col++) {
                    modules[row][col] = qr.isDark(row, col);
                }
            }

            return modules;
        }

        const qrModules = generateQRPattern();

        // Fine-grained cell state management (grid + radials + rings)
        const STORAGE_KEY_BASE = 'qr-circle-base';
        const STORAGE_KEY_ALGORITHM = 'qr-circle-algorithm'; // Cache for algorithm results
        const STORAGE_KEY_CHECKBOXES = 'qr-circle-checkboxes'; // Cache for checkbox states
        let baseModuleState = {}; // { "row,col": true/false } - base QR pattern

        // Algorithm state (automatic conversion result)
        // Store sector colors directly, without grid subdivision
        let sectorColors = {}; // { "radial:idx|ring:idx": true/false } - sector-based colors (main algorithm)
        let sectorColorsWithEdge = {}; // { "radial:idx|ring:idx": true/false } - with edge extension applied
        let sectorColorsOptimized = {}; // { "radial:idx|ring:idx": true/false } - with coverage optimization applied
        let edgeExtensionEnabled = false; // Whether to apply edge extension
        let coverageOptimizationEnabled = false; // Whether to apply coverage optimization
        let algorithmState = {}; // Legacy: for comparison with manual edits
        let whiteRingStrokeWidth = 1.0; // White ring decoration stroke width (configurable)
        let algorithmStats = null; // Algorithm execution statistics

        // Finder pattern parameters (configurable)
        let finderOuterRadius = 3.5;   // Outer radius of finder pattern
        let finderRingWidth = 1.0;     // Width of the ring (outer - middle)
        let finderCenterRadius = 1.5;  // Radius of center dot

        // Alignment pattern parameters (configurable)
        let alignmentCenterRadius = 0.5; // Radius of alignment pattern center dot

        // ========== SKIP REGIONS (excluded from sector conversion) ==========
        // These regions are drawn with special patterns (finder/alignment) or reserved for logo
        // Coordinates are in module units (0-28 for QR v3)

        // Finder pattern regions (7x7 + 1 separator = 8x8 each)
        // NOTE: Alignment pattern is NOT excluded - it will be converted to sectors like other data areas

        // Logo and excluded regions - precomputed boolean grid for O(1) lookup
        // Source: mask.json - 195 cells total
        // Uses 29Ã—29 boolean array (841 bytes) for fastest possible query performance
        const SKIP_GRID = (() => {
            const grid = Array(29).fill(null).map(() => Array(29).fill(false));

            // Helper to mark a cell as skip region
            const markSkip = (row, col) => {
                if (row >= 0 && row < 29 && col >= 0 && col < 29) {
                    grid[row][col] = true;
                }
            };

            // 1. ä¸­å¿ƒlogoåŒºï¼ˆä¸è§„åˆ™å½¢çŠ¶ï¼‰
            for (let row = 9; row <= 16; row++) markSkip(row, 9);   // åˆ—9
            for (let row = 10; row <= 17; row++) markSkip(row, 10); // åˆ—10
            for (let row = 9; row <= 20; row++) markSkip(row, 11);  // åˆ—11
            for (let row = 8; row <= 19; row++) markSkip(row, 12);  // åˆ—12
            for (let row = 9; row <= 20; row++) markSkip(row, 13);  // åˆ—13
            for (let row = 10; row <= 21; row++) markSkip(row, 14); // åˆ—14
            for (let row = 9; row <= 20; row++) markSkip(row, 15);  // åˆ—15
            for (let row = 8; row <= 19; row++) markSkip(row, 16);  // åˆ—16
            for (let row = 9; row <= 20; row++) markSkip(row, 17);  // åˆ—17
            for (let row = 10; row <= 21; row++) markSkip(row, 18); // åˆ—18

            // 2. å³ä¸‹è§’tail marginï¼ˆ4Ã—4çŸ©å½¢ï¼‰
            for (let row = 25; row <= 28; row++) {
                for (let col = 25; col <= 28; col++) {
                    markSkip(row, col);
                }
            }

            // 3. Finder patternåˆ†éš”æ¡
            // å·¦ä¸Šfinder
            for (let col = 0; col <= 7; col++) markSkip(7, col);
            for (let row = 0; row <= 7; row++) markSkip(row, 7);
            // å³ä¸Šfinder
            for (let col = 21; col <= 28; col++) markSkip(7, col);
            for (let row = 0; row <= 7; row++) markSkip(row, 21);
            // å·¦ä¸‹finder
            for (let col = 0; col <= 7; col++) markSkip(21, col);
            for (let row = 21; row <= 28; row++) markSkip(row, 7);

            // 4. Timing patternåˆ†éš”ç‚¹
            for (let col = 9; col <= 19; col += 2) markSkip(6, col);  // è¡Œ6
            for (let row = 9; row <= 19; row += 2) markSkip(row, 6);  // åˆ—6

            // 5. å·¦ä¸‹è§’æ•£ç‚¹
            [17, 18, 19, 20].forEach(row => markSkip(row, 0));
            [18, 19, 20].forEach(row => markSkip(row, 1));

            // Count marked cells for verification
            let count = 0;
            for (let row = 0; row < 29; row++) {
                for (let col = 0; col < 29; col++) {
                    if (grid[row][col]) count++;
                }
            }
            console.log(`[SKIP_GRID] Precomputed ${count} skip cells (expected: 195) in 29Ã—29 grid`);

            return grid;
        })();

        // Legacy definitions (kept for reference, replaced by SKIP_GRID)
        // const FINDER_REGIONS = [
        //     { rowMin: 0, rowMax: 8, colMin: 0, colMax: 8, name: 'Top-left finder' },
        //     { rowMin: 0, rowMax: 8, colMin: 21, colMax: 29, name: 'Top-right finder' },
        //     { rowMin: 21, rowMax: 29, colMin: 0, colMax: 8, name: 'Bottom-left finder' }
        // ];
        // const LOGO_REGION = { cx: 14.5, cy: 14.5, r: 4, name: 'Center logo' };
        // const TAIL_MARGIN_REGION = { rowMin: 25, rowMax: 29, colMin: 25, colMax: 29, name: 'Tail margin' };

        // Helper: Check if a point (in module coordinates) is in any skip region
        // Optimized for high-frequency calls (called ~50k times during sector generation)
        function isPointInSkipRegion(x, y) {
            // Fast path: bounds check first
            const col = Math.floor(x);
            const row = Math.floor(y);
            if (row < 0 || row >= 29 || col < 0 || col >= 29) {
                return false;
            }

            // O(1) lookup in precomputed grid - fastest possible
            // Includes: finder regions, logo, tail margin, timing separators
            return SKIP_GRID[row][col];
        }

        // Helper: Check if a sector overlaps significantly with skip regions
        // Returns true if more than 50% of sector sample points are in skip regions
        function shouldSkipSector(radialIndex, ringIndex) {
            const angle1 = radialIndex * RADIAL_ANGLE * Math.PI / 180;
            const angle2 = (radialIndex + 1) * RADIAL_ANGLE * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Sample 9 points in the sector
            let skipCount = 0;
            const samples = 9;
            for (let ri = 0; ri < 3; ri++) {
                for (let ai = 0; ai < 3; ai++) {
                    const r = r1 + (r2 - r1) * (ri + 0.5) / 3;
                    const a = angle1 + (angle2 - angle1) * (ai + 0.5) / 3;
                    const x = center.x + r * Math.cos(a);
                    const y = center.y + r * Math.sin(a);

                    if (isPointInSkipRegion(x, y)) {
                        skipCount++;
                    }
                }
            }

            // Skip if majority of sample points are in skip regions
            return skipCount > samples / 2;
        }

        // Helper: Check if a module (by row, col) is in skip region
        // This is a convenience wrapper for isPointInSkipRegion using module center
        function isModuleInSkipRegion(row, col) {
            return isPointInSkipRegion(col + 0.5, row + 0.5);
        }

        const RADIAL_COUNT = 240; // 240 radial lines (every 1.5Â°)
        const RADIAL_ANGLE = 360 / RADIAL_COUNT; // Degrees per sector (1.5Â°)
        const RING_INTERVAL = 0.5; // Ring every 0.5 units
        const maxRadius = Math.sqrt(2) * moduleCount / 2;
        const RING_COUNT = Math.ceil(maxRadius / RING_INTERVAL);

        // Coverage detection thresholds
        const MIN_BLACK_COVERAGE = 0.75; // Black modules must have >= 75% coverage
        const MAX_WHITE_COVERAGE = 0.25; // White modules must have <= 25% coverage

        // Initialize base state
        function initializeBaseState() {
            baseModuleState = {};
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    baseModuleState[`${row},${col}`] = qrModules[row][col];
                }
            }
            localStorage.setItem(STORAGE_KEY_BASE, JSON.stringify(baseModuleState));
        }

        // Always initialize with freshly generated QR code
        // (ignore localStorage to ensure we use the latest QR data)
        initializeBaseState();

        // Create global defs for clipPaths
        const globalDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        globalDefs.setAttribute('id', 'global-defs');
        svg.appendChild(globalDefs);

        // Create mask for white rings - only show where algorithm layer has data
        function createWhiteRingMask() {
            // Remove old mask if exists
            const oldMask = document.getElementById('white-ring-mask');
            if (oldMask) oldMask.remove();

            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', 'white-ring-mask');

            // Start with all hidden (black background)
            const background = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            background.setAttribute('x', -100);
            background.setAttribute('y', -100);
            background.setAttribute('width', moduleCount + 200);
            background.setAttribute('height', moduleCount + 200);
            background.setAttribute('fill', 'black');
            mask.appendChild(background);

            // Only show regions where algorithm layer has data
            if (Object.keys(sectorColors).length === 0) {
                // No algorithm data, mask stays black (nothing visible)
                globalDefs.appendChild(mask);
                return;
            }

            // Choose data source based on optimization toggles
            let dataSource = sectorColors;
            if (coverageOptimizationEnabled) {
                dataSource = sectorColorsOptimized;
            } else if (edgeExtensionEnabled) {
                dataSource = sectorColorsWithEdge;
            }

            // Draw white sectors only for BLACK regions (where algorithm draws green)
            for (const [sectorId, color] of Object.entries(dataSource)) {
                // Only include black regions (color = true), skip white regions
                if (!color) continue;

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create sector path in mask (white = visible)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', 'white'); // White in mask = visible
                path.setAttribute('stroke', 'none');

                mask.appendChild(path);
            }

            globalDefs.appendChild(mask);
            console.log('[White Ring Mask] Created mask with', Object.keys(dataSource).length, 'sectors');
        }

        // Module layer (for finder patterns, alignment patterns, etc.)
        const moduleLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        moduleLayer.setAttribute('id', 'module-layer');
        svg.appendChild(moduleLayer);

        // === Layer architecture (bottom to top) ===
        // Layer 1: Original QR layer (red + white background, fully opaque)
        const originalDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        originalDisplayLayer.setAttribute('id', 'layer-1-original');
        originalDisplayLayer.setAttribute('opacity', '1'); // Fully opaque
        svg.appendChild(originalDisplayLayer);

        // Layer 2: Auxiliary debug layer (above original, below algorithm)
        const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        gridLayer.setAttribute('id', 'grid-layer');
        svg.appendChild(gridLayer);

        const circleLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        circleLayer.setAttribute('id', 'circle-layer');
        svg.appendChild(circleLayer);

        const radialLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        radialLayer.setAttribute('id', 'radial-layer');
        svg.appendChild(radialLayer);

        // Layer 3: Algorithm annular layer (green, fully opaque)
        const algorithmDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        algorithmDisplayLayer.setAttribute('id', 'layer-3-algorithm');
        algorithmDisplayLayer.setAttribute('opacity', '0.5'); // Semi-transparent to show guide lines
        svg.appendChild(algorithmDisplayLayer);

        // Layer 4: White ring decoration layer (on top of algorithm layer)
        const whiteRingLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        whiteRingLayer.setAttribute('id', 'white-ring-layer');
        svg.appendChild(whiteRingLayer);

        // Error detection layer: highlight insufficient coverage (highest z-index)
        const errorLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        errorLayer.setAttribute('id', 'error-layer');
        svg.appendChild(errorLayer);

        // Legacy algorithm layer (kept for compatibility)
        const algorithmLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        algorithmLayer.setAttribute('id', 'algorithm-layer');
        algorithmLayer.setAttribute('opacity', '0.7'); // Semi-transparent for comparison
        svg.appendChild(algorithmLayer);

        // Draw grid
        function drawGrid() {
            gridLayer.innerHTML = '';

            // Vertical lines
            for (let i = 0; i <= moduleCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', i);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', i);
                line.setAttribute('y2', moduleCount);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                gridLayer.appendChild(line);
            }

            // Horizontal lines
            for (let i = 0; i <= moduleCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', i);
                line.setAttribute('x2', moduleCount);
                line.setAttribute('y2', i);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                gridLayer.appendChild(line);
            }
        }

        // Draw circles (every 0.5 unit)
        function drawCircles() {
            circleLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2; // Diagonal distance

            for (let r = 0.5; r <= maxRadius; r += 0.5) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', center.x);
                circle.setAttribute('cy', center.y);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ff6b6b');
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.setAttribute('opacity', '0.5');
                circleLayer.appendChild(circle);
            }
        }

        // Draw radial lines
        function drawRadialLines() {
            radialLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2;

            for (let degree = 0; degree < 360; degree += RADIAL_ANGLE) {
                const angle = degree * Math.PI / 180; // Convert to radians
                const x2 = center.x + maxRadius * Math.cos(angle);
                const y2 = center.y + maxRadius * Math.sin(angle);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', center.x);
                line.setAttribute('y1', center.y);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#4ecdc4');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                line.setAttribute('opacity', '0.5');
                radialLayer.appendChild(line);
            }

            // Draw center point
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', center.x);
            centerDot.setAttribute('cy', center.y);
            centerDot.setAttribute('r', '0.1');
            centerDot.setAttribute('fill', '#4ecdc4');
            radialLayer.appendChild(centerDot);
        }

        // Draw white rings - complete circles clipped by algorithm layer mask
        function drawWhiteRings() {
            whiteRingLayer.innerHTML = '';

            // Check if algorithm has data
            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawWhiteRings] No algorithm data, skipping white rings');
                return;
            }

            // Apply mask to only show where algorithm layer has data (intersection)
            whiteRingLayer.setAttribute('mask', 'url(#white-ring-mask)');

            // Choose data source based on optimization toggles to determine max ring
            let dataSource = sectorColors;
            let sourceLabel = 'base';
            if (coverageOptimizationEnabled) {
                dataSource = sectorColorsOptimized;
                sourceLabel = 'optimized';
            } else if (edgeExtensionEnabled) {
                dataSource = sectorColorsWithEdge;
                sourceLabel = 'edge-extended';
            }

            // Find the maximum ring index from the data
            let maxRingIndex = 0;
            for (const sectorId of Object.keys(dataSource)) {
                const match = sectorId.match(/ring:(\d+)/);
                if (match) {
                    maxRingIndex = Math.max(maxRingIndex, parseInt(match[1]));
                }
            }

            console.log(`[drawWhiteRings] Drawing complete circles with mask, maxRingIndex=${maxRingIndex}, source=${sourceLabel}`);

            // Draw complete concentric circles (will be clipped by mask)
            for (let ringIndex = 0; ringIndex <= maxRingIndex; ringIndex++) {
                const radius = (ringIndex + 0.5) * RING_INTERVAL; // Center of ring

                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', center.x);
                circle.setAttribute('cy', center.y);
                circle.setAttribute('r', radius);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', whiteRingStrokeWidth.toString());
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.setAttribute('opacity', '0.8');

                whiteRingLayer.appendChild(circle);
            }

            console.log(`[drawWhiteRings] âœ… Drew ${maxRingIndex + 1} complete circles with mask intersection`);
        }

        // ========== ALGORITHM: Automatic Sector-Ring Conversion ==========

        // Create a complete sector (annular segment) path - NO grid clipping
        function createCompleteSectorPath(radialIndex, ringIndex) {
            const angle1 = radialIndex * RADIAL_ANGLE * Math.PI / 180;
            const angle2 = (radialIndex + 1) * RADIAL_ANGLE * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Calculate four vertices
            const x1_inner = center.x + r1 * Math.cos(angle1);
            const y1_inner = center.y + r1 * Math.sin(angle1);
            const x2_inner = center.x + r1 * Math.cos(angle2);
            const y2_inner = center.y + r1 * Math.sin(angle2);
            const x1_outer = center.x + r2 * Math.cos(angle1);
            const y1_outer = center.y + r2 * Math.sin(angle1);
            const x2_outer = center.x + r2 * Math.cos(angle2);
            const y2_outer = center.y + r2 * Math.sin(angle2);

            // Determine if arc is large (> 180 degrees)
            const largeArc = (angle2 - angle1) > Math.PI ? 1 : 0;

            // Build annular sector path
            let pathData = `M ${x1_inner} ${y1_inner}`;  // Start at inner arc, angle1
            pathData += ` A ${r1} ${r1} 0 ${largeArc} 1 ${x2_inner} ${y2_inner}`;  // Inner arc to angle2
            pathData += ` L ${x2_outer} ${y2_outer}`;  // Line to outer arc
            pathData += ` A ${r2} ${r2} 0 ${largeArc} 0 ${x1_outer} ${y1_outer}`;  // Outer arc back to angle1
            pathData += ` Z`;  // Close path

            return pathData;
        }

        // Check if a point is inside an annular sector (ring segment)
        function isPointInSector(px, py, radialIndex, ringIndex) {
            const dx = px - center.x;
            const dy = py - center.y;
            const radius = Math.sqrt(dx * dx + dy * dy);

            // Check radius range
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            if (radius < r1 || radius > r2) return false;

            // Check angle range
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            const a1 = radialIndex * RADIAL_ANGLE;
            const a2 = (radialIndex + 1) * RADIAL_ANGLE;

            return angle >= a1 && angle < a2;
        }

        // Calculate overlap area between a sector and a grid cell using Monte Carlo sampling
        function calculateOverlapArea(gridRow, gridCol, radialIndex, ringIndex, samples = 100) {
            let hits = 0;

            // Sample points in the grid cell
            for (let i = 0; i < samples; i++) {
                for (let j = 0; j < samples; j++) {
                    const px = gridCol + (i + 0.5) / samples;
                    const py = gridRow + (j + 0.5) / samples;

                    if (isPointInSector(px, py, radialIndex, ringIndex)) {
                        hits++;
                    }
                }
            }

            const cellArea = 1.0; // Unit cell area
            return (hits / (samples * samples)) * cellArea;
        }

        // Find all sectors that overlap with a grid cell
        function findOverlappingSectors(gridRow, gridCol) {
            const overlaps = [];
            const maxRadius = Math.sqrt(2) * moduleCount / 2;
            const maxRing = Math.ceil(maxRadius / RING_INTERVAL);

            // Check cell center to determine which radials/rings might overlap
            const cellCenterX = gridCol + 0.5;
            const cellCenterY = gridRow + 0.5;
            const dx = cellCenterX - center.x;
            const dy = cellCenterY - center.y;
            const cellRadius = Math.sqrt(dx * dx + dy * dy);
            let cellAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (cellAngle < 0) cellAngle += 360;

            // Search nearby rings (Â±1 from cell center ring)
            const centerRing = Math.floor(cellRadius / RING_INTERVAL);
            for (let ring = Math.max(0, centerRing - 1); ring <= Math.min(maxRing, centerRing + 2); ring++) {
                // Search nearby radials (expand search range for smaller sectors)
                const searchRange = Math.ceil(3 / RADIAL_ANGLE * 2); // At least Â±3 degrees coverage
                const centerRadial = Math.floor(cellAngle / RADIAL_ANGLE);
                for (let radial = centerRadial - searchRange; radial <= centerRadial + searchRange; radial++) {
                    const normalizedRadial = ((radial % RADIAL_COUNT) + RADIAL_COUNT) % RADIAL_COUNT;

                    // Increase sampling for smaller sectors
                    const samplePoints = Math.max(50, Math.ceil(100 / RADIAL_ANGLE));
                    const overlapArea = calculateOverlapArea(gridRow, gridCol, normalizedRadial, ring, samplePoints);
                    if (overlapArea > 0.0005) { // Lower threshold for smaller sectors
                        const cellId = `grid:${gridRow},${gridCol}|radial:${normalizedRadial}|ring:${ring}`;
                        overlaps.push({
                            cellId,
                            radialIndex: normalizedRadial,
                            ringIndex: ring,
                            overlapArea
                        });
                    }
                }
            }

            return overlaps;
        }

        // Find all grid cells that overlap with a sector
        function findOverlappingGridCells(radialIndex, ringIndex) {
            const overlaps = [];

            // Determine bounding box of the sector
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const a1 = radialIndex * RADIAL_ANGLE * Math.PI / 180;
            const a2 = (radialIndex + 1) * RADIAL_ANGLE * Math.PI / 180;

            // Calculate sector bounding box
            const points = [
                { x: center.x + r1 * Math.cos(a1), y: center.y + r1 * Math.sin(a1) },
                { x: center.x + r1 * Math.cos(a2), y: center.y + r1 * Math.sin(a2) },
                { x: center.x + r2 * Math.cos(a1), y: center.y + r2 * Math.sin(a1) },
                { x: center.x + r2 * Math.cos(a2), y: center.y + r2 * Math.sin(a2) }
            ];

            const minRow = Math.floor(Math.min(...points.map(p => p.y))) - 1;
            const maxRow = Math.ceil(Math.max(...points.map(p => p.y))) + 1;
            const minCol = Math.floor(Math.min(...points.map(p => p.x))) - 1;
            const maxCol = Math.ceil(Math.max(...points.map(p => p.x))) + 1;

            // Check each grid cell in bounding box
            for (let row = minRow; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    // Increase sampling for smaller sectors
                    const samplePoints = Math.max(50, Math.ceil(100 / RADIAL_ANGLE));
                    const overlapArea = calculateOverlapArea(row, col, radialIndex, ringIndex, samplePoints);
                    if (overlapArea > 0.0005) { // Lower threshold for smaller sectors
                        overlaps.push({
                            gridRow: row,
                            gridCol: col,
                            overlapArea
                        });
                    }
                }
            }

            return overlaps;
        }

        // Helper: Check if a module is in finder pattern 7x7 region
        function isInFinderPatternRegion(row, col) {
            // Top-left (0-6, 0-6)
            if (row >= 0 && row <= 6 && col >= 0 && col <= 6) return true;
            // Top-right (0-6, 22-28)
            if (row >= 0 && row <= 6 && col >= 22 && col <= 28) return true;
            // Bottom-left (22-28, 0-6)
            if (row >= 22 && row <= 28 && col >= 0 && col <= 6) return true;
            return false;
        }

        // Helper: Check if a module is in alignment pattern inner 3x3 region
        // Alignment pattern is at (22, 22), 5x5 total, inner 3x3 is (21-23, 21-23)
        function isInAlignmentPatternInner(row, col) {
            return row >= 21 && row <= 23 && col >= 21 && col <= 23;
        }

        // Helper: Check if a module is an edge module (on QR rectangular boundary)
        // Uses Cartesian coordinates (row, col), not polar coordinates
        // For QR v3 (29Ã—29): edge modules are the outermost ring (row/col 0 or 28)
        // Example: (0,0), (0,15), (28,28), (15,0) are edge modules
        //          (1,1), (3,3), (14,14) are inner modules
        function isEdgeModule(row, col) {
            return row === 0 || row === moduleCount - 1 ||
                   col === 0 || col === moduleCount - 1;
        }

        // Helper: Check if a sector is an edge sector (partially inside and partially outside QR rectangular boundary)
        // A sector is "edge" if some vertices are inside [0, moduleCount] and some are outside
        function isEdgeSector(radialIndex, ringIndex) {
            const angle1 = radialIndex * RADIAL_ANGLE * Math.PI / 180;
            const angle2 = (radialIndex + 1) * RADIAL_ANGLE * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Calculate four vertices of the sector (in Cartesian coordinates)
            const vertices = [
                { x: center.x + r1 * Math.cos(angle1), y: center.y + r1 * Math.sin(angle1) }, // Inner, angle1
                { x: center.x + r1 * Math.cos(angle2), y: center.y + r1 * Math.sin(angle2) }, // Inner, angle2
                { x: center.x + r2 * Math.cos(angle1), y: center.y + r2 * Math.sin(angle1) }, // Outer, angle1
                { x: center.x + r2 * Math.cos(angle2), y: center.y + r2 * Math.sin(angle2) }  // Outer, angle2
            ];

            const qrMin = 0;
            const qrMax = moduleCount; // 29 for version 3

            let hasInside = false;
            let hasOutside = false;

            // Check each vertex against rectangular boundary
            for (const vertex of vertices) {
                const isInside = vertex.x >= qrMin && vertex.x <= qrMax &&
                                 vertex.y >= qrMin && vertex.y <= qrMax;
                if (isInside) {
                    hasInside = true;
                } else {
                    hasOutside = true;
                }

                // If we found both inside and outside vertices, it's an edge sector
                if (hasInside && hasOutside) {
                    return true;
                }
            }

            return false;
        }

        // SIMPLIFIED ALGORITHM: Calculate sector color based on maximum overlap area
        function calculateSectorColor_Simplified(radialIndex, ringIndex, debug = false) {
            // Find all grid cells that overlap with this sector
            const overlappingGrids = findOverlappingGridCells(radialIndex, ringIndex);

            if (overlappingGrids.length === 0) {
                return false; // Default to white if no overlap
            }

            // Collect colors and areas
            const gridColors = new Set();
            const colorAreas = { black: 0, white: 0 };
            const gridDetails = [];
            let skippedCount = 0;

            for (const overlap of overlappingGrids) {
                const { gridRow, gridCol, overlapArea } = overlap;

                // Skip finder pattern 7x7 regions
                if (isInFinderPatternRegion(gridRow, gridCol)) {
                    skippedCount++;
                    if (debug) {
                        gridDetails.push({
                            grid: `${gridRow},${gridCol}`,
                            color: 'SKIPPED (Finder)',
                            area: overlapArea.toFixed(4)
                        });
                    }
                    continue;
                }

                // Skip alignment pattern inner 3x3 region
                if (isInAlignmentPatternInner(gridRow, gridCol)) {
                    skippedCount++;
                    if (debug) {
                        gridDetails.push({
                            grid: `${gridRow},${gridCol}`,
                            color: 'SKIPPED (Alignment Inner)',
                            area: overlapArea.toFixed(4)
                        });
                    }
                    continue;
                }

                // Check if module is in skip region (treat as white if in skip region)
                const isInSkipArea = isPointInSkipRegion(gridCol + 0.5, gridRow + 0.5);
                const isBlack = isInSkipArea ? false : (baseModuleState[`${gridRow},${gridCol}`] || false);

                gridColors.add(isBlack);

                if (isBlack) {
                    colorAreas.black += overlapArea;
                } else {
                    colorAreas.white += overlapArea;
                }

                if (debug) {
                    gridDetails.push({
                        grid: `${gridRow},${gridCol}`,
                        color: isInSkipArea ? 'white (skip region)' : (isBlack ? 'black' : 'white'),
                        area: overlapArea.toFixed(4)
                    });
                }
            }

            // If all grids were skipped, return white
            if (skippedCount === overlappingGrids.length) {
                if (debug) {
                    console.log(`[Sector ${radialIndex},${ringIndex}] All grids skipped (finder/alignment)`);
                }
                return false;
            }

            // Standard case: All grids have the same color, or majority color
            const result = gridColors.size === 1
                ? Array.from(gridColors)[0]
                : colorAreas.black > colorAreas.white;

            if (debug) {
                console.log(`[Sector ${radialIndex},${ringIndex}] Algorithm Result:`, {
                    overlappingGrids: gridDetails,
                    skippedGrids: skippedCount,
                    colorAreas: {
                        black: colorAreas.black.toFixed(4),
                        white: colorAreas.white.toFixed(4)
                    },
                    sameColor: gridColors.size === 1,
                    result: result ? 'BLACK' : 'WHITE'
                });
            }

            return result;
        }

        // Apply edge extension: For edge sectors, apply additive approach
        // Returns a new sectorColors object with edge extension applied
        function applyEdgeExtension() {
            console.log('[Edge Extension] Starting...');
            const startTime = performance.now();

            // Start with a copy of the main algorithm results
            const extendedColors = { ...sectorColors };
            let edgeModifications = 0;
            let edgeSectorCount = 0;
            let candidateCount = 0;
            let hasBlackOnly = 0;
            let hasWhiteOnly = 0;
            let hasBoth = 0;
            let hasNeither = 0;
            let edgeBlackInMain = 0;
            let edgeWhiteInMain = 0;

            // Process all sectors
            for (const [sectorId, color] of Object.entries(sectorColors)) {
                // Parse sector ID
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Check if this is an edge sector
                if (!isEdgeSector(radialIndex, ringIndex)) continue;

                edgeSectorCount++;

                // Track edge sector color in main algorithm
                if (color) {
                    edgeBlackInMain++;
                } else {
                    edgeWhiteInMain++;
                }

                // Get overlapping grids to check conditions
                const overlappingGrids = findOverlappingGridCells(radialIndex, ringIndex);
                let hasBlackModule = false;
                let hasWhiteModule = false;
                const moduleDetails = [];

                for (const overlap of overlappingGrids) {
                    const { gridRow, gridCol } = overlap;

                    // Skip modules outside QR boundary (only check modules within [0, moduleCount-1])
                    if (gridRow < 0 || gridRow >= moduleCount || gridCol < 0 || gridCol >= moduleCount) {
                        continue;
                    }

                    // Skip special regions
                    if (isInFinderPatternRegion(gridRow, gridCol)) continue;
                    if (isInAlignmentPatternInner(gridRow, gridCol)) continue;

                    // Check module color (considering skip regions)
                    const isInSkipArea = isPointInSkipRegion(gridCol + 0.5, gridRow + 0.5);
                    const isBlack = isInSkipArea ? false : (baseModuleState[`${gridRow},${gridCol}`] || false);

                    moduleDetails.push({
                        row: gridRow,
                        col: gridCol,
                        isBlack: isBlack,
                        isInSkipArea: isInSkipArea
                    });

                    if (isBlack) {
                        hasBlackModule = true;
                    } else {
                        hasWhiteModule = true;
                    }
                }

                // Categorize edge sectors by module coverage
                let category = '';
                if (hasBlackModule && !hasWhiteModule) {
                    hasBlackOnly++;
                    category = 'Black only';
                } else if (!hasBlackModule && hasWhiteModule) {
                    hasWhiteOnly++;
                    category = 'White only';
                } else if (hasBlackModule && hasWhiteModule) {
                    hasBoth++;
                    category = 'Both black and white';
                } else {
                    hasNeither++;
                    category = 'Neither';
                }

                // Detailed logging disabled - use summary statistics instead

                // Apply edge rule: if edge sector + has black + NO white modules â†’ force BLACK
                // Only extend when sector only covers black modules (plus boundary-outside area)
                // If it also covers white modules, don't extend (would pollute white areas)
                if (hasBlackModule && !hasWhiteModule) {
                    candidateCount++;
                    if (!color) { // If was white, change to black
                        extendedColors[sectorId] = true;
                        edgeModifications++;
                        console.log(`[Edge Extension] Modified sector ${sectorId}: WHITE â†’ BLACK (only covers black modules)`);
                    } else {
                        console.log(`[Edge Extension] Candidate ${sectorId}: Already BLACK, no change needed`);
                    }
                }
            }

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);

            console.log(`[Edge Extension] âœ… Completed in ${elapsed}s`);
            console.log(`[Edge Extension] Total sectors: ${Object.keys(sectorColors).length}`);
            console.log(`[Edge Extension] Edge sectors (crossing boundary): ${edgeSectorCount}`);
            console.log(`[Edge Extension] Edge sectors in main algorithm:`);
            console.log(`  - BLACK in main: ${edgeBlackInMain}`);
            console.log(`  - WHITE in main: ${edgeWhiteInMain}`);
            console.log(`[Edge Extension] Edge sector module coverage:`);
            console.log(`  - Black only (no white): ${hasBlackOnly}`);
            console.log(`  - White only (no black): ${hasWhiteOnly}`);
            console.log(`  - Both black and white: ${hasBoth}`);
            console.log(`  - Neither (only outside QR): ${hasNeither}`);
            console.log(`[Edge Extension] Candidates (black only, no white): ${candidateCount}`);
            console.log(`[Edge Extension] Modified (WHITEâ†’BLACK): ${edgeModifications}`);

            return extendedColors;
        }

        // Helper: Calculate coverage of a module given a sector color configuration
        function calculateModuleCoverage(row, col, sectorColorConfig, sampleSize = 10) {
            const blackSectorsSet = new Set();
            for (const [sectorId, color] of Object.entries(sectorColorConfig)) {
                if (color) blackSectorsSet.add(sectorId);
            }

            let coveredCount = 0;
            const totalCount = sampleSize * sampleSize;

            for (let i = 0; i < sampleSize; i++) {
                for (let j = 0; j < sampleSize; j++) {
                    const x = col + (i + 0.5) / sampleSize;
                    const y = row + (j + 0.5) / sampleSize;
                    if (isPointCovered(x, y, blackSectorsSet)) {
                        coveredCount++;
                    }
                }
            }

            return coveredCount / totalCount;
        }

        // Apply coverage optimization: Greedy algorithm with testing validation
        // For each problematic black module, try painting sectors (largest coverage first)
        // and test if it breaks neighboring modules' coverage constraints
        function applyCoverageOptimization() {
            console.log('[Coverage Opt] ğŸš€ Starting greedy optimization with testing...');
            const startTime = performance.now();

            // Configuration
            const MIN_FIXABLE_COVERAGE = 0.50; // è·³è¿‡è¦†ç›–ç‡å¤ªä½çš„ï¼ˆ<50%å¾ˆéš¾ä¿®å¤ï¼‰
            const MAX_WHITE_COVERAGE_TO_FIX = 0.75; // è·³è¿‡è¦†ç›–ç‡å¤ªé«˜çš„ï¼ˆ>75%å¾ˆéš¾ä¿®å¤ï¼‰
            const MIN_CANDIDATE_SECTORS = 1; // è‡³å°‘è¦æœ‰1ä¸ªå€™é€‰æ‰‡åŒº
            const MAX_ITERATIONS = 5; // æœ€å¤§è¿­ä»£æ¬¡æ•°
            const sampleSize = 10;

            // Debug configuration: track all problematic modules in detail
            const DEBUG_ALL_ERRORS = true; // Set to false to disable detailed debugging
            const DEBUG_RADIUS = 1; // Track neighbors within this radius

            // Track which modules were attempted but failed to fix
            const failedToFixModules = new Set();

            // Helper: Check if module should be debugged (for neighbors)
            const shouldDebug = (row, col, targetRow, targetCol) => {
                if (!DEBUG_ALL_ERRORS) return false;
                const rowDist = Math.abs(row - targetRow);
                const colDist = Math.abs(col - targetCol);
                return rowDist <= DEBUG_RADIUS && colDist <= DEBUG_RADIUS;
            };

            // Start with edge-extended results
            const optimizedColors = { ...sectorColorsWithEdge };

            // Global statistics
            let totalIterations = 0;
            let globalTotalModifications = 0;
            let globalTotalFixed = 0;

            // Multi-round iteration
            for (let iteration = 1; iteration <= MAX_ITERATIONS; iteration++) {
                totalIterations = iteration;
                console.log(`\n[Coverage Opt] â•â•â• ITERATION ${iteration}/${MAX_ITERATIONS} â•â•â•`);

                let iterationModifications = 0;
                let iterationFixed = 0;

                // Step 1: Re-detect problematic modules (based on current state)
                const problematicBlackModules = [];
                const problematicWhiteModules = [];

                for (let row = 0; row < moduleCount; row++) {
                    for (let col = 0; col < moduleCount; col++) {
                        // Skip special regions
                        if (isInFinderPatternRegion(row, col)) continue;
                        if (isInAlignmentPatternInner(row, col)) continue;
                        if (isPointInSkipRegion(col + 0.5, row + 0.5)) continue;

                        const isBlack = baseModuleState[`${row},${col}`] || false;
                        const coverage = calculateModuleCoverage(row, col, optimizedColors, sampleSize);

                        if (isBlack && coverage < MIN_BLACK_COVERAGE) {
                            problematicBlackModules.push({ row, col, coverage });
                        } else if (!isBlack && coverage > MAX_WHITE_COVERAGE) {
                            problematicWhiteModules.push({ row, col, coverage });
                        }
                    }
                }

                console.log(`[Coverage Opt] Found ${problematicBlackModules.length} black + ${problematicWhiteModules.length} white problematic modules`);

                // Early exit if no problematic modules
                if (problematicBlackModules.length === 0 && problematicWhiteModules.length === 0) {
                    console.log(`[Coverage Opt] âœ… All modules fixed!`);
                    break;
                }

                // Step 1.5: Sort by priority
                problematicBlackModules.sort((a, b) => b.coverage - a.coverage);
                problematicWhiteModules.sort((a, b) => a.coverage - b.coverage);

                // Step 2: For each problematic BLACK module, try adding black sectors
                console.log(`[Coverage Opt] --- Phase 1: Fixing BLACK modules (WHITEâ†’BLACK) ---`);
                let blackModificationsThisPhase = 0;
                let blackFixedThisPhase = 0;
                let blackSkippedThisPhase = 0;

                for (const module of problematicBlackModules) {
                    const { row, col, coverage: initialCoverage } = module;
                    let wasFixed = false;

                    // Skip unfixable modules
                    if (initialCoverage < MIN_FIXABLE_COVERAGE) {
                        blackSkippedThisPhase++;
                        continue;
                    }

                    // Find all sectors that overlap with this module
                    const overlappingSectors = findOverlappingSectors(row, col);

                    // Construct candidate sectors
                    const candidateSectors = overlappingSectors
                        .filter(s => s && s.radialIndex !== undefined && s.ringIndex !== undefined)
                        // Skip sectors in skip regions (they don't exist in sectorColors)
                        .filter(s => !shouldSkipSector(s.radialIndex, s.ringIndex))
                        .map(s => {
                            const sectorId = `radial:${s.radialIndex}|ring:${s.ringIndex}`;
                            return {
                                sectorId,
                                coverageOfModule: s.overlapArea / 1.0,
                                radialIndex: s.radialIndex,
                                ringIndex: s.ringIndex
                            };
                        })
                        .filter(s => optimizedColors[s.sectorId] === false) // Only white sectors (explicitly false, not undefined)
                        .sort((a, b) => b.coverageOfModule - a.coverageOfModule);

                    // Skip if no candidates
                    if (candidateSectors.length < MIN_CANDIDATE_SECTORS) {
                        blackSkippedThisPhase++;
                        continue;
                    }

                    // Track rejection reasons for debugging
                    const rejectionReasons = [];

                    // Step 3: Greedy trial - try each candidate from largest to smallest
                    for (const candidate of candidateSectors) {
                        const { sectorId } = candidate;

                        if (!sectorId || typeof sectorId !== 'string') continue;

                        // Temporarily paint this sector black
                        optimizedColors[sectorId] = true;

                        // Test: Get all modules affected by this sector
                        const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                        if (!match) {
                            optimizedColors[sectorId] = false;
                            continue;
                        }
                        const radialIndex = parseInt(match[1]);
                        const ringIndex = parseInt(match[2]);
                        const affectedCells = findOverlappingGridCells(radialIndex, ringIndex);

                        let testPassed = true;
                        let failedCell = null;
                        const affectedDebugCells = [];

                        // Check each affected module's coverage
                        for (const cell of affectedCells) {
                            const { gridRow, gridCol } = cell;

                            if (gridRow < 0 || gridRow >= moduleCount || gridCol < 0 || gridCol >= moduleCount) continue;
                            if (isInFinderPatternRegion(gridRow, gridCol)) continue;
                            if (isInAlignmentPatternInner(gridRow, gridCol)) continue;
                            if (isModuleInSkipRegion(gridRow, gridCol)) continue;

                            // CRITICAL: Skip the target module itself - we're trying to fix it!
                            // It's OK if it's still below threshold, as long as we're making progress
                            if (gridRow === row && gridCol === col) {
                                continue;
                            }

                            const isModuleBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
                            const newCoverage = calculateModuleCoverage(gridRow, gridCol, optimizedColors, sampleSize);

                            // Track affected cells for debugging
                            if (shouldDebug(gridRow, gridCol)) {
                                affectedDebugCells.push({ gridRow, gridCol, isModuleBlack, newCoverage });
                            }

                            // Test coverage constraints for OTHER modules (not the target)
                            if (isModuleBlack && newCoverage < MIN_BLACK_COVERAGE) {
                                testPassed = false;
                                failedCell = { gridRow, gridCol, isModuleBlack, newCoverage, reason: `BLACK < ${MIN_BLACK_COVERAGE * 100}%` };
                                break;
                            }
                            if (!isModuleBlack && newCoverage > MAX_WHITE_COVERAGE) {
                                testPassed = false;
                                failedCell = { gridRow, gridCol, isModuleBlack, newCoverage, reason: `WHITE > ${MAX_WHITE_COVERAGE * 100}%` };
                                break;
                            }
                        }

                        if (testPassed) {
                            blackModificationsThisPhase++;
                            const newCoverage = calculateModuleCoverage(row, col, optimizedColors, sampleSize);

                            if (newCoverage >= MIN_BLACK_COVERAGE) {
                                blackFixedThisPhase++;
                                wasFixed = true;
                                break;
                            }
                        } else {
                            // Revert modification
                            optimizedColors[sectorId] = false;
                        }
                    }
                }

                // Step 3: For each problematic WHITE module, try removing black sectors
                console.log(`\n[Coverage Opt] --- Phase 2: Fixing WHITE modules (BLACKâ†’WHITE) ---`);
                let whiteModificationsThisPhase = 0;
                let whiteFixedThisPhase = 0;
                let whiteSkippedThisPhase = 0;

                for (const module of problematicWhiteModules) {
                    const { row, col, coverage: initialCoverage } = module;

                    // Skip modules with too high coverage
                    if (initialCoverage > MAX_WHITE_COVERAGE) {
                        whiteSkippedThisPhase++;
                        continue;
                    }

                    // Find all sectors that overlap with this module
                    const overlappingSectors = findOverlappingSectors(row, col);

                    // For white modules, filter for BLACK sectors to remove
                    const candidateSectors = overlappingSectors
                        .filter(s => s && s.radialIndex !== undefined && s.ringIndex !== undefined)
                        // Skip sectors in skip regions (they don't exist in sectorColors)
                        .filter(s => !shouldSkipSector(s.radialIndex, s.ringIndex))
                        .map(s => {
                            const sectorId = `radial:${s.radialIndex}|ring:${s.ringIndex}`;
                            return {
                                sectorId,
                                coverageOfModule: s.overlapArea / 1.0,
                                radialIndex: s.radialIndex,
                                ringIndex: s.ringIndex
                            };
                        })
                        .filter(s => optimizedColors[s.sectorId] === true) // Only BLACK sectors (explicitly true)
                        .sort((a, b) => b.coverageOfModule - a.coverageOfModule);

                    // Skip if no candidates
                    if (candidateSectors.length < MIN_CANDIDATE_SECTORS) {
                        whiteSkippedThisPhase++;
                        continue;
                    }

                // Greedy trial - try removing each black sector from largest to smallest
                for (const candidate of candidateSectors) {
                    const { sectorId } = candidate;

                    if (!sectorId || typeof sectorId !== 'string') {
                        console.warn(`[Coverage Opt] Invalid sectorId:`, sectorId);
                        continue;
                    }

                    // Temporarily erase this sector (BLACKâ†’WHITE)
                    const originalValue = optimizedColors[sectorId];
                    delete optimizedColors[sectorId]; // Or set to false

                    // Test: Get all modules affected by this sector
                    const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                    if (!match) {
                        console.warn(`[Coverage Opt] Invalid sectorId format: ${sectorId}`);
                        optimizedColors[sectorId] = originalValue;
                        continue;
                    }
                    const radialIndex = parseInt(match[1]);
                    const ringIndex = parseInt(match[2]);
                    const affectedCells = findOverlappingGridCells(radialIndex, ringIndex);

                    let testPassed = true;

                    // Check each affected module's coverage
                    for (const cell of affectedCells) {
                        const { gridRow, gridCol } = cell;

                        // Skip out-of-bounds and special regions
                        if (gridRow < 0 || gridRow >= moduleCount || gridCol < 0 || gridCol >= moduleCount) continue;
                        if (isInFinderPatternRegion(gridRow, gridCol)) continue;
                        if (isInAlignmentPatternInner(gridRow, gridCol)) continue;
                        if (isModuleInSkipRegion(gridRow, gridCol)) continue;

                        // CRITICAL: Skip the target module itself - we're trying to fix it!
                        // It's OK if it's still above threshold, as long as we're making progress
                        if (gridRow === row && gridCol === col) {
                            continue;
                        }

                        const isModuleBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
                        const newCoverage = calculateModuleCoverage(gridRow, gridCol, optimizedColors, sampleSize);

                        // Test coverage constraints for OTHER modules (not the target)
                        if (isModuleBlack && newCoverage < MIN_BLACK_COVERAGE) {
                            testPassed = false;
                            break;
                        }
                        if (!isModuleBlack && newCoverage > MAX_WHITE_COVERAGE) {
                            testPassed = false;
                            break;
                        }
                    }

                    if (testPassed) {
                        whiteModificationsThisPhase++;
                        const newCoverage = calculateModuleCoverage(row, col, optimizedColors, sampleSize);

                        if (newCoverage <= MAX_WHITE_COVERAGE) {
                            whiteFixedThisPhase++;
                            break;
                        }
                    } else {
                        optimizedColors[sectorId] = originalValue;
                    }
                }
                }

                // Update iteration statistics
                iterationModifications = blackModificationsThisPhase + whiteModificationsThisPhase;
                iterationFixed = blackFixedThisPhase + whiteFixedThisPhase;
                globalTotalModifications += iterationModifications;
                globalTotalFixed += iterationFixed;

                // Print iteration summary
                console.log(`\n[Iter${iteration}] BLACK: ${blackFixedThisPhase} fixed | WHITE: ${whiteFixedThisPhase} fixed | Total: ${iterationFixed} fixed, ${iterationModifications} mods`);

                // Convergence check
                if (iterationFixed === 0) {
                    console.log(`[Coverage Opt] No improvements, stopping.\n`);
                    break;
                }
            } // End of iteration loop

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);

            console.log(`\n[Coverage Opt] âœ… COMPLETED in ${elapsed}s | ${totalIterations} iterations | ${globalTotalFixed} fixed | ${globalTotalModifications} mods\n`);

            // Final detailed analysis of remaining errors
            if (DEBUG_ALL_ERRORS) {
                console.log(`\n${'='.repeat(80)}`);
                console.log(`ğŸ“‹ è¯¦ç»†é”™è¯¯åˆ†æ - æ‰€æœ‰å‰©ä½™é—®é¢˜æ¨¡å—`);
                console.log(`${'='.repeat(80)}\n`);

                const remainingBlackErrors = [];
                const remainingWhiteErrors = [];

                // Re-detect errors
                for (let row = 0; row < moduleCount; row++) {
                    for (let col = 0; col < moduleCount; col++) {
                        if (isInFinderPatternRegion(row, col)) continue;
                        if (isInAlignmentPatternInner(row, col)) continue;
                        if (isModuleInSkipRegion(row, col)) continue;

                        const isBlack = baseModuleState[`${row},${col}`] || false;
                        const coverage = calculateModuleCoverage(row, col, optimizedColors, sampleSize);

                        if (isBlack && coverage < MIN_BLACK_COVERAGE) {
                            remainingBlackErrors.push({ row, col, coverage });
                        } else if (!isBlack && coverage > MAX_WHITE_COVERAGE) {
                            remainingWhiteErrors.push({ row, col, coverage });
                        }
                    }
                }

                console.log(`å‰©ä½™é”™è¯¯ï¼š${remainingBlackErrors.length} é»‘è‰²æ¨¡å— + ${remainingWhiteErrors.length} ç™½è‰²æ¨¡å—\n`);

                // Analyze each BLACK error
                remainingBlackErrors.forEach((error, index) => {
                    const { row, col, coverage } = error;
                    console.log(`${'â”€'.repeat(80)}`);
                    console.log(`âŒ é»‘è‰²æ¨¡å— #${index + 1}: (${row},${col}) | è¦†ç›–ç‡: ${(coverage * 100).toFixed(1)}% (éœ€è¦ â‰¥${MIN_BLACK_COVERAGE * 100}%)`);
                    console.log(`${'â”€'.repeat(80)}`);

                    // Get neighborsçŠ¶æ€
                    console.log(`\nå‘¨è¾¹æ¨¡å— (3Ã—3):`);
                    for (let dr = -1; dr <= 1; dr++) {
                        let line = '  ';
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr;
                            const nc = col + dc;
                            if (nr < 0 || nr >= moduleCount || nc < 0 || nc >= moduleCount) {
                                line += '[OUT] ';
                                continue;
                            }
                            if (isInFinderPatternRegion(nr, nc) || isInAlignmentPatternInner(nr, nc) || isModuleInSkipRegion(nr, nc)) {
                                line += '[MSK] ';
                                continue;
                            }
                            const nIsBlack = baseModuleState[`${nr},${nc}`] || false;
                            const nCov = calculateModuleCoverage(nr, nc, optimizedColors, sampleSize);
                            const type = nIsBlack ? 'B' : 'W';
                            const status = (nIsBlack && nCov < MIN_BLACK_COVERAGE) || (!nIsBlack && nCov > MAX_WHITE_COVERAGE) ? 'âŒ' : 'âœ…';
                            if (dr === 0 && dc === 0) {
                                line += `[â˜…${type}${(nCov * 100).toFixed(0)}] `;
                            } else {
                                line += `[${type}${(nCov * 100).toFixed(0)}${status}] `;
                            }
                        }
                        console.log(line);
                    }

                    // Get candidate sectors
                    const overlappingSectors = findOverlappingSectors(row, col);
                    const candidateSectors = overlappingSectors
                        .filter(s => s && s.radialIndex !== undefined && s.ringIndex !== undefined)
                        .map(s => {
                            const sectorId = `radial:${s.radialIndex}|ring:${s.ringIndex}`;
                            return {
                                sectorId,
                                coverageOfModule: s.overlapArea / 1.0,
                                isBlack: optimizedColors[sectorId] || false
                            };
                        })
                        .sort((a, b) => b.coverageOfModule - a.coverageOfModule);

                    const whiteCandidates = candidateSectors.filter(s => !s.isBlack);
                    console.log(`\nå€™é€‰ç™½è‰²æ‰‡åŒºï¼ˆå¯æ¶‚é»‘ï¼‰: ${whiteCandidates.length} ä¸ª`);
                    whiteCandidates.slice(0, 5).forEach((c, i) => {
                        console.log(`  ${i + 1}. ${c.sectorId} | è¦†ç›–: ${(c.coverageOfModule * 100).toFixed(1)}%`);
                    });

                    // Test each candidate
                    if (whiteCandidates.length > 0) {
                        console.log(`\næµ‹è¯•ç»“æœ:`);
                        for (const candidate of whiteCandidates.slice(0, 3)) {
                            const { sectorId } = candidate;

                            // Temporarily apply
                            const testColors = { ...optimizedColors };
                            testColors[sectorId] = true;

                            const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                            if (!match) continue;
                            const radialIndex = parseInt(match[1]);
                            const ringIndex = parseInt(match[2]);
                            const affectedCells = findOverlappingGridCells(radialIndex, ringIndex);

                            let reason = null;
                            for (const cell of affectedCells) {
                                const { gridRow, gridCol } = cell;
                                if (gridRow < 0 || gridRow >= moduleCount || gridCol < 0 || gridCol >= moduleCount) continue;
                                if (isInFinderPatternRegion(gridRow, gridCol)) continue;
                                if (isInAlignmentPatternInner(gridRow, gridCol)) continue;
                                if (isModuleInSkipRegion(gridRow, gridCol)) continue;
                                if (gridRow === row && gridCol === col) continue;

                                const isModuleBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
                                const newCoverage = calculateModuleCoverage(gridRow, gridCol, testColors, sampleSize);

                                if (isModuleBlack && newCoverage < MIN_BLACK_COVERAGE) {
                                    reason = `ä¼šç ´å (${gridRow},${gridCol}): BLACK ${(newCoverage * 100).toFixed(1)}% < ${MIN_BLACK_COVERAGE * 100}%`;
                                    break;
                                }
                                if (!isModuleBlack && newCoverage > MAX_WHITE_COVERAGE) {
                                    reason = `ä¼šç ´å (${gridRow},${gridCol}): WHITE ${(newCoverage * 100).toFixed(1)}% > ${MAX_WHITE_COVERAGE * 100}%`;
                                    break;
                                }
                            }

                            if (reason) {
                                console.log(`  âŒ ${sectorId}: ${reason}`);
                            } else {
                                const newCoverage = calculateModuleCoverage(row, col, testColors, sampleSize);
                                console.log(`  âœ… ${sectorId}: å¯åº”ç”¨ï¼æ–°è¦†ç›–ç‡ ${(newCoverage * 100).toFixed(1)}%`);
                            }
                        }
                    } else {
                        console.log(`  âš ï¸  æ— å€™é€‰æ‰‡åŒºï¼ˆæ‰€æœ‰æ‰‡åŒºéƒ½å·²æ¶‚é»‘ï¼‰`);
                    }

                    console.log();
                });

                // Analyze each WHITE error (similar structure)
                remainingWhiteErrors.forEach((error, index) => {
                    const { row, col, coverage } = error;
                    console.log(`${'â”€'.repeat(80)}`);
                    console.log(`âŒ ç™½è‰²æ¨¡å— #${index + 1}: (${row},${col}) | è¦†ç›–ç‡: ${(coverage * 100).toFixed(1)}% (éœ€è¦ â‰¤${MAX_WHITE_COVERAGE * 100}%)`);
                    console.log(`${'â”€'.repeat(80)}`);

                    // Get neighbors
                    console.log(`\nå‘¨è¾¹æ¨¡å— (3Ã—3):`);
                    for (let dr = -1; dr <= 1; dr++) {
                        let line = '  ';
                        for (let dc = -1; dc <= 1; dc++) {
                            const nr = row + dr;
                            const nc = col + dc;
                            if (nr < 0 || nr >= moduleCount || nc < 0 || nc >= moduleCount) {
                                line += '[OUT] ';
                                continue;
                            }
                            if (isInFinderPatternRegion(nr, nc) || isInAlignmentPatternInner(nr, nc) || isModuleInSkipRegion(nr, nc)) {
                                line += '[MSK] ';
                                continue;
                            }
                            const nIsBlack = baseModuleState[`${nr},${nc}`] || false;
                            const nCov = calculateModuleCoverage(nr, nc, optimizedColors, sampleSize);
                            const type = nIsBlack ? 'B' : 'W';
                            const status = (nIsBlack && nCov < MIN_BLACK_COVERAGE) || (!nIsBlack && nCov > MAX_WHITE_COVERAGE) ? 'âŒ' : 'âœ…';
                            if (dr === 0 && dc === 0) {
                                line += `[â˜…${type}${(nCov * 100).toFixed(0)}] `;
                            } else {
                                line += `[${type}${(nCov * 100).toFixed(0)}${status}] `;
                            }
                        }
                        console.log(line);
                    }

                    // Get candidate sectors (black sectors to remove)
                    const overlappingSectors = findOverlappingSectors(row, col);
                    const candidateSectors = overlappingSectors
                        .filter(s => s && s.radialIndex !== undefined && s.ringIndex !== undefined)
                        .map(s => {
                            const sectorId = `radial:${s.radialIndex}|ring:${s.ringIndex}`;
                            return {
                                sectorId,
                                coverageOfModule: s.overlapArea / 1.0,
                                isBlack: optimizedColors[sectorId] || false
                            };
                        })
                        .sort((a, b) => b.coverageOfModule - a.coverageOfModule);

                    const blackCandidates = candidateSectors.filter(s => s.isBlack);
                    console.log(`\nå€™é€‰é»‘è‰²æ‰‡åŒºï¼ˆå¯æ“¦é™¤ï¼‰: ${blackCandidates.length} ä¸ª`);
                    blackCandidates.slice(0, 5).forEach((c, i) => {
                        console.log(`  ${i + 1}. ${c.sectorId} | è¦†ç›–: ${(c.coverageOfModule * 100).toFixed(1)}%`);
                    });

                    // Test each candidate
                    if (blackCandidates.length > 0) {
                        console.log(`\næµ‹è¯•ç»“æœ:`);
                        for (const candidate of blackCandidates.slice(0, 3)) {
                            const { sectorId } = candidate;

                            // Temporarily remove
                            const testColors = { ...optimizedColors };
                            delete testColors[sectorId];

                            const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                            if (!match) continue;
                            const radialIndex = parseInt(match[1]);
                            const ringIndex = parseInt(match[2]);
                            const affectedCells = findOverlappingGridCells(radialIndex, ringIndex);

                            let reason = null;
                            for (const cell of affectedCells) {
                                const { gridRow, gridCol } = cell;
                                if (gridRow < 0 || gridRow >= moduleCount || gridCol < 0 || gridCol >= moduleCount) continue;
                                if (isInFinderPatternRegion(gridRow, gridCol)) continue;
                                if (isInAlignmentPatternInner(gridRow, gridCol)) continue;
                                if (isModuleInSkipRegion(gridRow, gridCol)) continue;
                                if (gridRow === row && gridCol === col) continue;

                                const isModuleBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
                                const newCoverage = calculateModuleCoverage(gridRow, gridCol, testColors, sampleSize);

                                if (isModuleBlack && newCoverage < MIN_BLACK_COVERAGE) {
                                    reason = `ä¼šç ´å (${gridRow},${gridCol}): BLACK ${(newCoverage * 100).toFixed(1)}% < ${MIN_BLACK_COVERAGE * 100}%`;
                                    break;
                                }
                                if (!isModuleBlack && newCoverage > MAX_WHITE_COVERAGE) {
                                    reason = `ä¼šç ´å (${gridRow},${gridCol}): WHITE ${(newCoverage * 100).toFixed(1)}% > ${MAX_WHITE_COVERAGE * 100}%`;
                                    break;
                                }
                            }

                            if (reason) {
                                console.log(`  âŒ ${sectorId}: ${reason}`);
                            } else {
                                const newCoverage = calculateModuleCoverage(row, col, testColors, sampleSize);
                                console.log(`  âœ… ${sectorId}: å¯åº”ç”¨ï¼æ–°è¦†ç›–ç‡ ${(newCoverage * 100).toFixed(1)}%`);
                            }
                        }
                    } else {
                        console.log(`  âš ï¸  æ— å€™é€‰æ‰‡åŒºï¼ˆæ‰€æœ‰æ‰‡åŒºéƒ½æ˜¯ç™½è‰²ï¼‰`);
                    }

                    console.log();
                });

                console.log(`${'='.repeat(80)}`);
                console.log(`ğŸ“‹ åˆ†æå®Œæˆ`);
                console.log(`${'='.repeat(80)}\n`);
            }

            return optimizedColors;
        }

        // Check if a grid cell violates the white coverage constraint
        function checkGridConstraint(gridRow, gridCol) {
            const isGridBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
            const gridArea = 1.0;
            const maxChange = gridArea * MAX_WHITE_COVERAGE;

            const overlappingSectors = findOverlappingSectors(gridRow, gridCol);

            let totalChange = 0;
            for (const sector of overlappingSectors) {
                const sectorColor = algorithmState[sector.cellId];
                if (sectorColor === undefined) continue;

                const overlapArea = sector.overlapArea;

                if (isGridBlack && !sectorColor) {
                    // Grid black, sector white -> subtraction
                    totalChange += overlapArea;
                } else if (!isGridBlack && sectorColor) {
                    // Grid white, sector black -> addition
                    totalChange += overlapArea;
                }
            }

            return {
                violated: totalChange > maxChange,
                totalChange,
                maxChange,
                percentage: (totalChange / gridArea) * 100
            };
        }

        // Save algorithm results to localStorage
        function saveAlgorithmResults() {
            try {
                const data = {
                    sectorColors,
                    sectorColorsWithEdge,
                    sectorColorsOptimized,
                    algorithmStats,
                    timestamp: Date.now()
                };
                localStorage.setItem(STORAGE_KEY_ALGORITHM, JSON.stringify(data));
                console.log('[Algorithm Cache] âœ… Saved to localStorage');
            } catch (e) {
                console.error('[Algorithm Cache] Failed to save:', e);
            }
        }

        // Load algorithm results from localStorage
        function loadAlgorithmResults() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_ALGORITHM);
                if (!saved) {
                    console.log('[Algorithm Cache] No cached results found');
                    return false;
                }

                const data = JSON.parse(saved);
                sectorColors = data.sectorColors || {};
                sectorColorsWithEdge = data.sectorColorsWithEdge || {};
                sectorColorsOptimized = data.sectorColorsOptimized || {};
                algorithmStats = data.algorithmStats || null;

                const age = Date.now() - (data.timestamp || 0);
                const ageMinutes = Math.floor(age / 60000);

                console.log(`[Algorithm Cache] âœ… Loaded cached results (${ageMinutes} minutes old)`);
                console.log(`[Algorithm Cache] Sectors: ${Object.keys(sectorColors).length}`);

                return true;
            } catch (e) {
                console.error('[Algorithm Cache] Failed to load:', e);
                return false;
            }
        }

        // Save all checkbox and slider states to localStorage
        function saveCheckboxStates() {
            try {
                const states = {};

                // Save checkbox states
                const checkboxes = document.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(cb => {
                    if (cb.id) {
                        states[cb.id] = cb.checked;
                    }
                });

                // Save slider/range states
                const sliders = document.querySelectorAll('input[type="range"]');
                sliders.forEach(slider => {
                    if (slider.id) {
                        states[slider.id] = slider.value;
                    }
                });

                localStorage.setItem(STORAGE_KEY_CHECKBOXES, JSON.stringify(states));
                console.log('[State Cache] âœ… Saved states:', Object.keys(states).length, 'controls');
            } catch (e) {
                console.error('[State Cache] Failed to save:', e);
            }
        }

        // Load all checkbox and slider states from localStorage
        function loadCheckboxStates() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY_CHECKBOXES);
                if (!saved) {
                    console.log('[State Cache] No cached states found');
                    return false;
                }

                const states = JSON.parse(saved);
                let restoredCount = 0;

                for (const [id, value] of Object.entries(states)) {
                    const element = document.getElementById(id);
                    if (!element) continue;

                    if (element.type === 'checkbox') {
                        element.checked = value;
                        restoredCount++;
                    } else if (element.type === 'range') {
                        element.value = value;
                        // Update displayed value
                        const valueDisplay = document.getElementById(id + '-value');
                        if (valueDisplay) {
                            valueDisplay.textContent = parseFloat(value).toFixed(1);
                        }
                        // Update global variables for sliders
                        if (id === 'finder-outer-radius') finderOuterRadius = parseFloat(value);
                        if (id === 'finder-ring-width') finderRingWidth = parseFloat(value);
                        if (id === 'finder-center-radius') finderCenterRadius = parseFloat(value);
                        if (id === 'alignment-center-radius') alignmentCenterRadius = parseFloat(value);
                        if (id === 'white-ring-width') whiteRingStrokeWidth = parseFloat(value);
                        restoredCount++;
                    }
                }

                console.log(`[State Cache] âœ… Restored ${restoredCount} control states`);
                return true;
            } catch (e) {
                console.error('[State Cache] Failed to load:', e);
                return false;
            }
        }

        // SIMPLIFIED ALGORITHM: Pure sector-based conversion using Monte Carlo
        async function runConversionAlgorithm() {
            console.log('[Algorithm] ğŸš€ Starting PURE SECTOR-BASED conversion...');
            const startTime = performance.now();

            sectorColors = {};
            algorithmState = {}; // Also populate for comparison
            let sameColorCount = 0;
            let differentColorCount = 0;

            const maxRadius = Math.sqrt(2) * moduleCount / 2;
            const maxRing = Math.ceil(maxRadius / RING_INTERVAL);
            const totalSectors = RADIAL_COUNT * maxRing;

            console.log('[Algorithm] Processing sectors (radial Ã— ring)...');
            let processed = 0;

            // Iterate through all sectors (radial, ring) - NO grid subdivision
            let skippedCount = 0;
            for (let ring = 0; ring <= maxRing; ring++) {
                for (let radial = 0; radial < RADIAL_COUNT; radial++) {
                    // Skip sectors that overlap with special regions (finder, alignment, logo, tail)
                    if (shouldSkipSector(radial, ring)) {
                        skippedCount++;
                        continue;
                    }

                    // Calculate color for this complete sector
                    const color = calculateSectorColor_Simplified(radial, ring);
                    const sectorId = `radial:${radial}|ring:${ring}`;
                    sectorColors[sectorId] = color;

                    // Also populate algorithmState for comparison with manual edits
                    // (manual edits are grid-subdivided, so we need to map sectors to grids)
                    const overlappingGrids = findOverlappingGridCells(radial, ring);
                    for (const overlap of overlappingGrids) {
                        const cellId = `grid:${overlap.gridRow},${overlap.gridCol}|radial:${radial}|ring:${ring}`;
                        algorithmState[cellId] = color;
                    }

                    // Track statistics
                    const colors = new Set(overlappingGrids.map(g => baseModuleState[`${g.gridRow},${g.gridCol}`] || false));
                    if (colors.size === 1) {
                        sameColorCount++;
                    } else {
                        differentColorCount++;
                    }

                    processed++;
                    if (processed % 200 === 0) {
                        console.log(`[Algorithm] Processed ${processed}/${totalSectors} sectors (skipped ${skippedCount})`);
                    }
                }
            }
            console.log(`[Algorithm] Skipped ${skippedCount} sectors in special regions`);

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);

            algorithmStats = {
                totalSectors: Object.keys(sectorColors).length,
                sameColorSectors: sameColorCount,
                mixedColorSectors: differentColorCount,
                elapsedSeconds: elapsed
            };

            console.log('[Algorithm] âœ… Completed!', algorithmStats);
            console.log(`[Algorithm] Pure sectors: ${Object.keys(sectorColors).length}`);
            console.log(`[Algorithm] Grid-mapped cells: ${Object.keys(algorithmState).length}`);

            // Automatically run edge extension
            sectorColorsWithEdge = applyEdgeExtension();

            // Automatically run coverage optimization
            try {
                console.log('[Main] Running coverage optimization...');
                sectorColorsOptimized = applyCoverageOptimization();
                console.log('[Main] Coverage optimization completed');
            } catch (error) {
                console.error('[Main] Coverage optimization failed:', error);
                sectorColorsOptimized = { ...sectorColorsWithEdge }; // Fallback
            }

            // Save results to cache
            saveAlgorithmResults();

            return algorithmStats;
        }


        // Fix a violated grid cell by flipping sectors with least impact
        function fixViolatedCell(gridRow, gridCol) {
            const isGridBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
            const overlappingSectors = findOverlappingSectors(gridRow, gridCol);

            // Find sectors to flip
            const candidates = [];
            for (const sector of overlappingSectors) {
                const sectorColor = algorithmState[sector.cellId];
                if (sectorColor === undefined) continue;

                // If grid is black and sector is white (contributing to violation), consider flipping to black
                // If grid is white and sector is black (contributing to violation), consider flipping to white
                if ((isGridBlack && !sectorColor) || (!isGridBlack && sectorColor)) {
                    candidates.push({
                        cellId: sector.cellId,
                        overlapArea: sector.overlapArea
                    });
                }
            }

            // Flip the largest overlapping sector (most impact)
            if (candidates.length > 0) {
                candidates.sort((a, b) => b.overlapArea - a.overlapArea);
                const toFlip = candidates[0];
                algorithmState[toFlip.cellId] = !algorithmState[toFlip.cellId];
            }
        }

        // Draw algorithm result - PURE SECTOR SHAPES (no grid clipping)
        function drawAlgorithmResult() {
            algorithmLayer.innerHTML = '';

            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawAlgorithmResult] No sector colors to draw');
                return;
            }

            let drawnCount = 0;

            // Draw complete sectors (annular segments) - NO grid subdivision
            for (const [sectorId, color] of Object.entries(sectorColors)) {
                // Only draw black regions (skip white)
                if (!color) continue;

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path (no clipping)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#00FF00'); // Green (ç®—æ³•ç»“æœ)
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                algorithmLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawAlgorithmResult] Drew', drawnCount, 'complete sectors (pure annular segments)');
        }

        // === NEW: Three independent display functions ===

        // Helper: Draw circular finder pattern on specified layer
        function drawCircularFinderPatternOnLayer(layer, centerX, centerY, color) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `finder-mask-${centerX}-${centerY}-${color}-${Date.now()}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Calculate radii based on configurable parameters
            const outerR = finderOuterRadius;
            const middleR = finderOuterRadius - finderRingWidth;
            const innerR = finderCenterRadius;

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', outerR);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black - creates white ring)
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', middleR);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', innerR);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            layer.appendChild(defs);

            // Draw the outer ring
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', outerR);
            outerRing.setAttribute('fill', color);
            outerRing.setAttribute('mask', `url(#${maskId})`);
            layer.appendChild(outerRing);

            // Draw the center dot
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', innerR);
            centerDot.setAttribute('fill', color);
            layer.appendChild(centerDot);
        }

        // Helper: Draw circular alignment pattern on specified layer (ring pattern)
        // 5x5 pattern: Black(1) - White(1) - Black(1) - White(1) - Black(1)
        // Radii: outer=2.5, middle=1.5, center=configurable
        function drawCircularAlignmentPatternOnLayer(layer, centerX, centerY, color) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `alignment-mask-${centerX}-${centerY}-${color}-${Date.now()}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white) - radius 2.5
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 2.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black) - radius 1.5, creates white ring
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', 1.5);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white) - radius configurable, allows center dot to show
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', alignmentCenterRadius);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            layer.appendChild(defs);

            // Draw the outer ring with mask
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 2.5);
            outerRing.setAttribute('fill', color);
            outerRing.setAttribute('mask', `url(#${maskId})`);
            layer.appendChild(outerRing);

            // Draw the center dot - radius configurable
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', alignmentCenterRadius);
            centerDot.setAttribute('fill', color);
            layer.appendChild(centerDot);
        }

        // Draw original QR code (rectangular coordinate system, red)
        function drawOriginalDisplay() {
            originalDisplayLayer.innerHTML = '';

            // Define special pattern regions to exclude from rectangular drawing
            const specialPatternModules = new Set();

            // Finder pattern regions (7x7 + separator)
            const finderRegions = [
                { rowMin: 0, rowMax: 8, colMin: 0, colMax: 8 },      // Top-left
                { rowMin: 0, rowMax: 8, colMin: 21, colMax: 29 },    // Top-right
                { rowMin: 21, rowMax: 29, colMin: 0, colMax: 8 }     // Bottom-left
            ];

            finderRegions.forEach(region => {
                for (let row = region.rowMin; row < region.rowMax; row++) {
                    for (let col = region.colMin; col < region.colMax; col++) {
                        if (row < moduleCount && col < moduleCount) {
                            specialPatternModules.add(`${row},${col}`);
                        }
                    }
                }
            });

            // Alignment pattern region (5x5 for QR v3)
            for (let row = 20; row <= 24; row++) {
                for (let col = 20; col <= 24; col++) {
                    specialPatternModules.add(`${row},${col}`);
                }
            }

            // Draw all regular modules (both black and white for opaque background)
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    // Skip special pattern areas
                    if (specialPatternModules.has(`${row},${col}`)) continue;

                    const isBlack = baseModuleState[`${row},${col}`];

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', col);
                    rect.setAttribute('y', row);
                    rect.setAttribute('width', 1);
                    rect.setAttribute('height', 1);
                    rect.setAttribute('fill', isBlack ? '#FF0000' : '#FFFFFF'); // Red for black, white for white
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('shape-rendering', 'crispEdges');

                    originalDisplayLayer.appendChild(rect);
                }
            }

            // Draw circular finder patterns (red color for original QR layer)
            const finderCenters = [
                { x: 3.5, y: 3.5 },      // Top-left
                { x: 25.5, y: 3.5 },     // Top-right
                { x: 3.5, y: 25.5 }      // Bottom-left
            ];
            finderCenters.forEach(center => {
                drawCircularFinderPatternOnLayer(originalDisplayLayer, center.x, center.y, '#FF0000');
            });

            // Draw circular alignment pattern (red color for original QR layer)
            drawCircularAlignmentPatternOnLayer(originalDisplayLayer, 22.5, 22.5, '#FF0000');
        }


        // Draw algorithm sectors (annular coordinate system, green)
        function drawAlgorithmDisplay() {
            algorithmDisplayLayer.innerHTML = '';

            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawAlgorithmDisplay] No sector colors to draw');
                return;
            }

            // Choose data source based on optimization toggles
            let dataSource = sectorColors;
            let sourceLabel = '(main algorithm)';
            if (coverageOptimizationEnabled) {
                dataSource = sectorColorsOptimized;
                sourceLabel = '(with coverage optimization)';
            } else if (edgeExtensionEnabled) {
                dataSource = sectorColorsWithEdge;
                sourceLabel = '(with edge extension)';
            }

            console.log(`[drawAlgorithmDisplay] Drawing from: ${sourceLabel}`);

            let drawnCount = 0;

            // 1. Draw algorithm sectors
            for (const [sectorId, color] of Object.entries(dataSource)) {
                if (!color) continue; // Only draw black regions

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#00FF00'); // Green
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                algorithmDisplayLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawAlgorithmDisplay] Drew', drawnCount, 'algorithm sectors');

            // 2. Draw skipped regions (copy from original QR layer but in green)

            // Draw circular finder patterns (green color for algorithm layer)
            const finderCenters = [
                { x: 3.5, y: 3.5 },      // Top-left
                { x: 25.5, y: 3.5 },     // Top-right
                { x: 3.5, y: 25.5 }      // Bottom-left
            ];
            finderCenters.forEach(center => {
                drawCircularFinderPatternOnLayer(algorithmDisplayLayer, center.x, center.y, '#00FF00');
            });

            // Draw circular alignment pattern inner 3x3 (green color for algorithm layer)
            drawCircularAlignmentPatternOnLayer(algorithmDisplayLayer, 22.5, 22.5, '#00FF00');

            console.log('[drawAlgorithmDisplay] Added skipped regions (finder patterns + alignment pattern) in green');
        }

        // === Coverage detection functions (OPTIMIZED) ===

        // Calculate which sector (radial, ring) a point belongs to - O(1)
        function getSectorIndicesForPoint(x, y) {
            const dx = x - center.x;
            const dy = y - center.y;
            const r = Math.sqrt(dx * dx + dy * dy);

            // Calculate angle in degrees [0, 360)
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            // Calculate sector indices directly
            const radialIndex = Math.floor(angle / RADIAL_ANGLE);
            const ringIndex = Math.floor(r / RING_INTERVAL);

            return { radialIndex, ringIndex };
        }

        // Check if a point is covered - O(1) with Set lookup
        // Check if a point is covered by white ring decoration
        function isPointInWhiteRing(x, y) {
            // Check if white ring layer is enabled
            const whiteRingEnabled = document.getElementById('show-layer-4-decoration').checked;
            if (!whiteRingEnabled) return false;

            // Check if point is in a region that white rings should skip
            const col = Math.floor(x);
            const row = Math.floor(y);

            // White rings skip: finder patterns, alignment inner 3x3, mask layer
            if (isInFinderPatternRegion(row, col) ||
                isInAlignmentPatternInner(row, col) ||
                isModuleInSkipRegion(row, col)) {
                return false;
            }

            // Calculate distance from center
            const dx = x - center.x;
            const dy = y - center.y;
            const radius = Math.sqrt(dx * dx + dy * dy);

            // White rings are drawn at intervals of RING_INTERVAL (0.5)
            // with stroke-width of 1, but we use a narrower detection zone
            // to avoid over-blocking (since stroke-width=1 would cover everything)
            const ringIndex = Math.round(radius / RING_INTERVAL);
            const ringRadius = ringIndex * RING_INTERVAL;
            const distanceToRing = Math.abs(radius - ringRadius);

            // Use conservative threshold: only block if very close to ring centerline
            // This represents the "core" of the white ring decoration
            const RING_DETECTION_THRESHOLD = 0.15; // ~30% of stroke-width
            return distanceToRing <= RING_DETECTION_THRESHOLD;
        }

        function isPointCovered(x, y, algorithmSectorsSet) {
            // White rings now only show where algorithm data exists (intersection),
            // so they don't affect coverage detection anymore

            const { radialIndex, ringIndex } = getSectorIndicesForPoint(x, y);
            const sectorId = `radial:${radialIndex}|ring:${ringIndex}`;

            // Fast Set lookup instead of array traversal
            if (algorithmSectorsSet && algorithmSectorsSet.has(sectorId)) {
                return true;
            }

            return false;
        }


        // Pre-compute algorithm sectors Set - called once
        function getAlgorithmSectorsSet() {
            // Choose data source based on optimization toggles
            let dataSource = sectorColors;
            if (coverageOptimizationEnabled) {
                dataSource = sectorColorsOptimized;
            } else if (edgeExtensionEnabled) {
                dataSource = sectorColorsWithEdge;
            }

            const blackSectors = new Set();
            for (const [sectorId, color] of Object.entries(dataSource)) {
                if (color) { // Only black sectors
                    blackSectors.add(sectorId);
                }
            }
            return blackSectors;
        }

        // Detect coverage errors - OPTIMIZED VERSION
        // Checks BOTH black and white modules:
        // - Black modules: coverage must be >= MIN_BLACK_COVERAGE
        // - White modules: coverage must be <= MAX_WHITE_COVERAGE
        function detectCoverageErrors(checkAlgorithm = true) {
            console.log('[detectCoverageErrors] Starting HIGH-PRECISION detection...');
            const startTime = performance.now();
            const errors = [];
            const sampleSize = 20; // Increased to 20 for higher precision (400 samples per module)
            let skippedCount = 0;
            let blackErrors = 0;
            let whiteErrors = 0;

            // MAJOR OPTIMIZATION: Pre-compute sector Sets once!
            const algorithmSectorsSet = checkAlgorithm ? getAlgorithmSectorsSet() : null;

            // Check if white ring decoration is enabled
            const whiteRingEnabled = document.getElementById('show-layer-4-decoration').checked;

            console.log(`[detectCoverageErrors] Pre-computed algorithm sectors: ${algorithmSectorsSet ? algorithmSectorsSet.size : 0}`);
            console.log(`[detectCoverageErrors] White ring decoration: ${whiteRingEnabled ? 'ENABLED (will affect coverage)' : 'DISABLED'}`);

            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    // Skip finder pattern 7x7 regions
                    if (isInFinderPatternRegion(row, col)) {
                        skippedCount++;
                        continue;
                    }

                    // Skip alignment pattern inner 3x3 region
                    if (isInAlignmentPatternInner(row, col)) {
                        skippedCount++;
                        continue;
                    }

                    // Skip masked modules (no need to check coverage for masked areas)
                    if (isModuleInSkipRegion(row, col)) {
                        skippedCount++;
                        continue;
                    }

                    const isBlack = baseModuleState[`${row},${col}`] || false;

                    let coveredCount = 0;
                    const totalCount = sampleSize * sampleSize;

                    // Sample points within module rectangle [col, col+1] Ã— [row, row+1]
                    for (let i = 0; i < sampleSize; i++) {
                        for (let j = 0; j < sampleSize; j++) {
                            const x = col + (i + 0.5) / sampleSize;
                            const y = row + (j + 0.5) / sampleSize;

                            // O(1) lookup instead of O(n) traversal!
                            if (isPointCovered(x, y, algorithmSectorsSet)) {
                                coveredCount++;
                            }
                        }
                    }

                    const coverage = coveredCount / totalCount;

                    // Check coverage constraints based on module color
                    let hasError = false;
                    if (isBlack) {
                        // Black module: coverage must be >= MIN_BLACK_COVERAGE
                        if (coverage < MIN_BLACK_COVERAGE) {
                            hasError = true;
                            blackErrors++;
                        }
                    } else {
                        // White module: coverage must be <= MAX_WHITE_COVERAGE
                        if (coverage > MAX_WHITE_COVERAGE) {
                            hasError = true;
                            whiteErrors++;
                        }
                    }

                    if (hasError) {
                        // Collect detailed information for error analysis
                        const overlappingSectors = findOverlappingSectors(row, col);
                        errors.push({
                            row,
                            col,
                            coverage,
                            isBlack,
                            overlappingSectors: overlappingSectors
                        });
                    }
                }
            }

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);
            console.log(`[detectCoverageErrors] âœ… Found ${errors.length} errors in ${elapsed}s`);
            console.log(`  - Black module errors (coverage < ${MIN_BLACK_COVERAGE * 100}%): ${blackErrors}`);
            console.log(`  - White module errors (coverage > ${MAX_WHITE_COVERAGE * 100}%): ${whiteErrors}`);
            console.log(`  - Skipped special/masked modules: ${skippedCount}`);

            // Output detailed error analysis
            if (errors.length > 0) {
                analyzeErrorDetails(errors, algorithmSectorsSet);
            }

            return errors;
        }

        // Analyze error details and output diagnostic information
        function analyzeErrorDetails(errors, algorithmSectorsSet) {
            console.log('\n' + '='.repeat(60));
            console.log('ğŸ“Š é”™è¯¯è¯¦ç»†åˆ†æ (Error Analysis)');
            console.log('='.repeat(60));

            // Limit output to first 10 errors for readability
            const errorsToAnalyze = errors.slice(0, 10);
            console.log(`åˆ†æå‰ ${errorsToAnalyze.length} ä¸ªé”™è¯¯ï¼ˆå…± ${errors.length} ä¸ªï¼‰:\n`);

            for (let i = 0; i < errorsToAnalyze.length; i++) {
                const error = errorsToAnalyze[i];
                const { row, col, coverage, isBlack, overlappingSectors } = error;

                console.log(`\nâ”â”â” é”™è¯¯ #${i + 1}: (${row}, ${col}) â”â”â”`);
                console.log(`  æ¨¡å—ç±»å‹: ${isBlack ? 'é»‘è‰² (BLACK)' : 'ç™½è‰² (WHITE)'}`);
                console.log(`  å®é™…è¦†ç›–ç‡: ${(coverage * 100).toFixed(1)}%`);
                console.log(`  æœŸæœ›è¦†ç›–ç‡: ${isBlack ? `â‰¥${MIN_BLACK_COVERAGE * 100}%` : `â‰¤${MAX_WHITE_COVERAGE * 100}%`}`);
                console.log(`  å·®å€¼: ${isBlack ? (coverage * 100 - MIN_BLACK_COVERAGE * 100).toFixed(1) : (coverage * 100 - MAX_WHITE_COVERAGE * 100).toFixed(1)}%`);

                // Analyze overlapping sectors
                const blackSectors = overlappingSectors.filter(s => algorithmSectorsSet.has(s.sectorId));
                const whiteSectors = overlappingSectors.filter(s => !algorithmSectorsSet.has(s.sectorId));

                console.log(`  è¦†ç›–æ‰‡åŒº: ${overlappingSectors.length} ä¸ª (${blackSectors.length} é»‘, ${whiteSectors.length} ç™½)`);

                if (blackSectors.length > 0) {
                    const sectorList = blackSectors.slice(0, 5).map(s => s.sectorId).join(', ');
                    console.log(`    é»‘è‰²æ‰‡åŒº: ${sectorList}${blackSectors.length > 5 ? '...' : ''}`);
                }

                // Analyze neighbors
                const neighbors = [];
                for (let dr = -1; dr <= 1; dr++) {
                    for (let dc = -1; dc <= 1; dc++) {
                        if (dr === 0 && dc === 0) continue;
                        const nr = row + dr;
                        const nc = col + dc;
                        if (nr >= 0 && nr < moduleCount && nc >= 0 && nc < moduleCount) {
                            const nIsBlack = baseModuleState[`${nr},${nc}`] || false;
                            const nIsInSkip = isModuleInSkipRegion(nr, nc);
                            neighbors.push({ row: nr, col: nc, isBlack: nIsBlack, isInSkipRegion: nIsInSkip });
                        }
                    }
                }

                const blackNeighbors = neighbors.filter(n => !n.isInSkipRegion && n.isBlack).length;
                const whiteNeighbors = neighbors.filter(n => !n.isInSkipRegion && !n.isBlack).length;
                const skipRegionNeighbors = neighbors.filter(n => n.isInSkipRegion).length;

                console.log(`  å‘¨è¾¹æ¨¡å— (3Ã—3): ${blackNeighbors} é»‘, ${whiteNeighbors} ç™½, ${skipRegionNeighbors} è·³è¿‡åŒºåŸŸ`);

                // Suggest potential cause
                if (isBlack && coverage < MIN_BLACK_COVERAGE) {
                    if (blackSectors.length === 0) {
                        console.log(`  âš ï¸  åŸå› åˆ†æ: é»‘è‰²æ¨¡å—ä½†æ— é»‘è‰²æ‰‡åŒºè¦†ç›–ï¼`);
                    } else if (coverage < 0.5) {
                        console.log(`  âš ï¸  åŸå› åˆ†æ: è¦†ç›–ç‡ä¸¥é‡ä¸è¶³ï¼ˆ<50%ï¼‰ï¼Œæ‰‡åŒºå¯èƒ½åç§»`);
                    } else {
                        console.log(`  âš ï¸  åŸå› åˆ†æ: éƒ¨åˆ†è¦†ç›–ä¸è¶³ï¼Œè¾¹ç¼˜å¯¹é½é—®é¢˜`);
                    }
                } else if (!isBlack && coverage > MAX_WHITE_COVERAGE) {
                    if (whiteSectors.length === 0) {
                        console.log(`  âš ï¸  åŸå› åˆ†æ: ç™½è‰²æ¨¡å—è¢«é»‘è‰²æ‰‡åŒºæ±¡æŸ“ï¼`);
                    } else {
                        console.log(`  âš ï¸  åŸå› åˆ†æ: é»‘è‰²æ‰‡åŒºæº¢å‡ºåˆ°ç™½è‰²åŒºåŸŸ`);
                    }
                }
            }

            console.log('\n' + '='.repeat(60) + '\n');
        }

        // Draw error markers on error layer
        // Red border: black module with insufficient coverage (< MIN_BLACK_COVERAGE)
        // Blue border: white module with excessive coverage (> MAX_WHITE_COVERAGE)
        function drawErrorMarkers(errors) {
            errorLayer.innerHTML = '';

            for (const error of errors) {
                const { row, col, coverage, isBlack } = error;

                // Choose color based on error type
                const errorColor = isBlack ? '#FF0000' : '#0066FF'; // Red for black, blue for white

                // Draw a thick border around the module
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', col);
                rect.setAttribute('y', row);
                rect.setAttribute('width', 1);
                rect.setAttribute('height', 1);
                rect.setAttribute('fill', 'none');
                rect.setAttribute('stroke', errorColor);
                rect.setAttribute('stroke-width', '0.08');
                rect.setAttribute('opacity', '0.9');

                errorLayer.appendChild(rect);

                // Add text label showing module coordinates (row, col)
                const coordText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                coordText.setAttribute('x', col + 0.5);
                coordText.setAttribute('y', row + 0.35);
                coordText.setAttribute('font-size', '0.18');
                coordText.setAttribute('fill', errorColor);
                coordText.setAttribute('text-anchor', 'middle');
                coordText.setAttribute('dominant-baseline', 'middle');
                coordText.setAttribute('font-weight', 'bold');
                coordText.textContent = `(${row},${col})`;

                errorLayer.appendChild(coordText);

                // Add text label showing coverage percentage
                const coverageText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                coverageText.setAttribute('x', col + 0.5);
                coverageText.setAttribute('y', row + 0.65);
                coverageText.setAttribute('font-size', '0.22');
                coverageText.setAttribute('fill', errorColor);
                coverageText.setAttribute('text-anchor', 'middle');
                coverageText.setAttribute('dominant-baseline', 'middle');
                coverageText.textContent = Math.round(coverage * 100) + '%';

                errorLayer.appendChild(coverageText);
            }

            console.log(`[drawErrorMarkers] Drew ${errors.length} error markers`);
        }

        // Check if position is in Finder Pattern
        function isInFinderPattern(row, col) {
            // Top-left (0-6, 0-6)
            if (row < 7 && col < 7) return 'top-left';
            // Top-right (0-6, 14-20)
            if (row < 7 && col >= 14) return 'top-right';
            // Bottom-left (14-20, 0-6)
            if (row >= 14 && col < 7) return 'bottom-left';
            return null;
        }

        // Draw circular finder patterns
        function drawCircularFinderPattern(centerX, centerY) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `finder-mask-${centerX}-${centerY}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 3.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black - creates white ring)
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', 2.5);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 1.5);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            moduleLayer.appendChild(defs);

            // Draw the outer ring (use yellow for visibility)
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 3.5);
            outerRing.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            outerRing.setAttribute('mask', `url(#${maskId})`);
            moduleLayer.appendChild(outerRing);

            // Draw the center dot (use yellow for visibility)
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 1.5);
            centerDot.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            moduleLayer.appendChild(centerDot);
        }

        // Draw circular alignment pattern (5x5 pattern for QR v3)
        function drawCircularAlignmentPattern(centerX, centerY) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `alignment-mask-${centerX}-${centerY}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 2.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Inner circle (black - creates white ring)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 1.5);
            innerCircle.setAttribute('fill', 'black');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            moduleLayer.appendChild(defs);

            // Draw the outer ring
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 2.5);
            outerRing.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            outerRing.setAttribute('mask', `url(#${maskId})`);
            moduleLayer.appendChild(outerRing);

            // Draw the center dot
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 1.5);
            centerDot.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            moduleLayer.appendChild(centerDot);
        }

        // Draw QR modules
        function drawModules() {
            moduleLayer.innerHTML = '';

            // Track which modules are in special patterns (to skip them)
            const specialPatternModules = new Set();

            // Draw circular finder patterns
            const finderCenters = [
                { x: 3.5, y: 3.5 },      // Top-left
                { x: 25.5, y: 3.5 },     // Top-right
                { x: 3.5, y: 25.5 }      // Bottom-left
            ];

            // Define finder pattern regions (7x7 squares + 1-cell separator)
            const finderRegions = [
                { rowMin: 0, rowMax: 7, colMin: 0, colMax: 7 },      // Top-left (0-6) + separator
                { rowMin: 0, rowMax: 7, colMin: 21, colMax: 28 },    // Top-right (21-27) + separator
                { rowMin: 21, rowMax: 28, colMin: 0, colMax: 7 }     // Bottom-left (21-27) + separator
            ];

            // Draw circular finder patterns
            for (let i = 0; i < finderCenters.length; i++) {
                const center = finderCenters[i];
                const region = finderRegions[i];

                drawCircularFinderPattern(center.x, center.y);

                // Mark modules in this finder pattern region (including separator)
                for (let row = region.rowMin; row < region.rowMax; row++) {
                    for (let col = region.colMin; col < region.colMax; col++) {
                        specialPatternModules.add(`${row},${col}`);
                    }
                }
            }

            // Draw circular alignment pattern (QR v3 has 1 alignment pattern at position 22,22)
            const alignmentCenter = { x: 22.5, y: 22.5 }; // Center at (22, 22), offset by 0.5
            drawCircularAlignmentPattern(alignmentCenter.x, alignmentCenter.y);

            // Mark alignment pattern region (5x5)
            for (let row = 20; row <= 24; row++) {
                for (let col = 20; col <= 24; col++) {
                    specialPatternModules.add(`${row},${col}`);
                }
            }

            // Draw regular modules (excluding special patterns) - base state only
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    if (specialPatternModules.has(`${row},${col}`)) continue;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', col);
                    rect.setAttribute('y', row);
                    rect.setAttribute('width', 1);
                    rect.setAttribute('height', 1);
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('shape-rendering', 'crispEdges');

                    // Fill based on base module state (use red for visibility)
                    if (baseModuleState[`${row},${col}`]) {
                        rect.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
                    } else {
                        rect.setAttribute('fill', 'white');
                    }

                    moduleLayer.appendChild(rect);
                }
            }
        }


        // Create cell using clipPath for precise intersection
        function createCellWithClip(gridRow, gridCol, radialIndex, ringIndex, cellId) {
            const angle1 = radialIndex * RADIAL_ANGLE * Math.PI / 180;
            const angle2 = (radialIndex + 1) * RADIAL_ANGLE * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Create annular sector (ring sector) path
            const x1_inner = center.x + r1 * Math.cos(angle1);
            const y1_inner = center.y + r1 * Math.sin(angle1);
            const x2_inner = center.x + r1 * Math.cos(angle2);
            const y2_inner = center.y + r1 * Math.sin(angle2);
            const x1_outer = center.x + r2 * Math.cos(angle1);
            const y1_outer = center.y + r2 * Math.sin(angle1);
            const x2_outer = center.x + r2 * Math.cos(angle2);
            const y2_outer = center.y + r2 * Math.sin(angle2);

            // Determine if arc is large (> 180 degrees)
            const largeArc = (angle2 - angle1) > Math.PI ? 1 : 0;

            // Build sector path
            let sectorPath = `M ${x1_inner} ${y1_inner}`;  // Start at inner arc, angle1
            sectorPath += ` A ${r1} ${r1} 0 ${largeArc} 1 ${x2_inner} ${y2_inner}`;  // Inner arc to angle2
            sectorPath += ` L ${x2_outer} ${y2_outer}`;  // Line to outer arc
            sectorPath += ` A ${r2} ${r2} 0 ${largeArc} 0 ${x1_outer} ${y1_outer}`;  // Outer arc back to angle1
            sectorPath += ` Z`;  // Close path

            // Create clipPath with grid rectangle
            const clipPathId = `clip-${cellId.replace(/:/g, '-').replace(/,/g, '_')}`;
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', clipPathId);

            const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            clipRect.setAttribute('x', gridCol);
            clipRect.setAttribute('y', gridRow);
            clipRect.setAttribute('width', 1);
            clipRect.setAttribute('height', 1);
            clipPath.appendChild(clipRect);

            // Create path with clipPath applied
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', sectorPath);
            path.setAttribute('clip-path', `url(#${clipPathId})`);

            return { path, clipPath };
        }

        // Old function (keep for reference, can be removed later)
        function createCellPath_OLD(gridRow, gridCol, radialIndex, ringIndex) {
            const angle1 = radialIndex * RADIAL_ANGLE * Math.PI / 180;
            const angle2 = (radialIndex + 1) * RADIAL_ANGLE * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const gridLeft = gridCol;
            const gridRight = gridCol + 1;
            const gridTop = gridRow;
            const gridBottom = gridRow + 1;

            // Helper: check if point is in grid bounds
            const inGrid = (x, y) => x >= gridLeft && x <= gridRight && y >= gridTop && y <= gridBottom;

            // Helper: clip line segment to grid rectangle
            const clipLineToGrid = (x1, y1, x2, y2) => {
                // Liang-Barsky algorithm for line-rectangle clipping
                let t0 = 0, t1 = 1;
                const dx = x2 - x1;
                const dy = y2 - y1;

                const clipTest = (p, q) => {
                    if (p === 0) return q >= 0;
                    const r = q / p;
                    if (p < 0) {
                        if (r > t1) return false;
                        if (r > t0) t0 = r;
                    } else {
                        if (r < t0) return false;
                        if (r < t1) t1 = r;
                    }
                    return true;
                };

                if (clipTest(-dx, x1 - gridLeft) &&
                    clipTest(dx, gridRight - x1) &&
                    clipTest(-dy, y1 - gridTop) &&
                    clipTest(dy, gridBottom - y1)) {
                    return {
                        x1: x1 + t0 * dx,
                        y1: y1 + t0 * dy,
                        x2: x1 + t1 * dx,
                        y2: y1 + t1 * dy
                    };
                }
                return null;
            };

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathData = '';
            const vertices = [];

            // Calculate radial line segments clipped to grid
            for (let angle of [angle1, angle2]) {
                const maxR = Math.sqrt(2) * moduleCount;
                const x1 = center.x + r1 * Math.cos(angle);
                const y1 = center.y + r1 * Math.sin(angle);
                const x2 = center.x + r2 * Math.cos(angle);
                const y2 = center.y + r2 * Math.sin(angle);

                const clipped = clipLineToGrid(x1, y1, x2, y2);
                if (clipped) {
                    vertices.push({x: clipped.x1, y: clipped.y1, angle, r: r1, type: 'radial'});
                    vertices.push({x: clipped.x2, y: clipped.y2, angle, r: r2, type: 'radial'});
                }
            }

            // Add arc endpoints if they're in grid
            for (let angle of [angle1, angle2]) {
                for (let r of [r1, r2]) {
                    const x = center.x + r * Math.cos(angle);
                    const y = center.y + r * Math.sin(angle);
                    if (inGrid(x, y)) {
                        // Already added by radial lines
                    }
                }
            }

            // Sort vertices by angle
            vertices.sort((a, b) => {
                const angleA = Math.atan2(a.y - center.y, a.x - center.x);
                const angleB = Math.atan2(b.y - center.y, b.x - center.x);
                if (Math.abs(angleA - angleB) < 0.001) {
                    return a.r - b.r; // Same angle, sort by radius
                }
                return angleA - angleB;
            });

            if (vertices.length < 2) return null;

            // Build path with arcs
            pathData = `M ${vertices[0].x} ${vertices[0].y}`;

            for (let i = 0; i < vertices.length; i++) {
                const curr = vertices[i];
                const next = vertices[(i + 1) % vertices.length];

                const currAngle = Math.atan2(curr.y - center.y, curr.x - center.x);
                const nextAngle = Math.atan2(next.y - center.y, next.x - center.x);
                const currR = Math.sqrt(Math.pow(curr.x - center.x, 2) + Math.pow(curr.y - center.y, 2));
                const nextR = Math.sqrt(Math.pow(next.x - center.x, 2) + Math.pow(next.y - center.y, 2));

                // Check if same radius (arc) or same angle (radial line)
                if (Math.abs(currR - nextR) < 0.01) {
                    // Arc segment
                    const largeArc = Math.abs(nextAngle - currAngle) > Math.PI ? 1 : 0;
                    pathData += ` A ${currR} ${currR} 0 ${largeArc} 1 ${next.x} ${next.y}`;
                } else {
                    // Line segment
                    pathData += ` L ${next.x} ${next.y}`;
                }
            }

            pathData += ' Z';
            path.setAttribute('d', pathData);
            return path;
        }

        // Initial draw
        drawGrid();
        drawCircles();
        drawRadialLines();
        createWhiteRingMask(); // Create mask before drawing rings
        drawWhiteRings();
        drawModules();

        // Draw new independent display layers
        drawOriginalDisplay();

        // Load cached checkbox states first (before algorithm results)
        loadCheckboxStates();

        // Apply loaded checkbox states to layer visibility
        const applyCheckboxStates = () => {
            // Layer 1: Original
            const showLayer1 = document.getElementById('show-layer-1-original');
            if (showLayer1) originalDisplayLayer.style.display = showLayer1.checked ? 'block' : 'none';

            // Layer 2: Auxiliary
            const showAux = document.getElementById('show-layer-2.5-auxiliary');
            const showGrid = document.getElementById('show-grid');
            const showCircles = document.getElementById('show-circles');
            const showRadials = document.getElementById('show-radials');
            if (showAux && showGrid && showCircles && showRadials) {
                const isAuxEnabled = showAux.checked;
                gridLayer.style.display = isAuxEnabled && showGrid.checked ? 'block' : 'none';
                circleLayer.style.display = isAuxEnabled && showCircles.checked ? 'block' : 'none';
                radialLayer.style.display = isAuxEnabled && showRadials.checked ? 'block' : 'none';

                // Enable/disable sub-checkboxes based on parent state
                showGrid.disabled = !isAuxEnabled;
                showCircles.disabled = !isAuxEnabled;
                showRadials.disabled = !isAuxEnabled;

                // Gray out labels when disabled
                showGrid.parentElement.style.opacity = isAuxEnabled ? '1' : '0.5';
                showCircles.parentElement.style.opacity = isAuxEnabled ? '1' : '0.5';
                showRadials.parentElement.style.opacity = isAuxEnabled ? '1' : '0.5';
            }

            // Layer 3: Algorithm sub-options
            const showLayer3 = document.getElementById('show-layer-3-algorithm');
            const edgeExtension = document.getElementById('toggle-edge-extension');
            const coverageOptimization = document.getElementById('toggle-coverage-optimization');
            if (showLayer3 && edgeExtension && coverageOptimization) {
                const isLayer3Enabled = showLayer3.checked;
                // Enable/disable sub-checkboxes based on parent state
                edgeExtension.disabled = !isLayer3Enabled;
                coverageOptimization.disabled = !isLayer3Enabled;
                // Gray out labels when disabled
                edgeExtension.parentElement.style.opacity = isLayer3Enabled ? '1' : '0.5';
                coverageOptimization.parentElement.style.opacity = isLayer3Enabled ? '1' : '0.5';
            }

            // Layer 4: Decoration
            const showLayer4 = document.getElementById('show-layer-4-decoration');
            if (showLayer4) whiteRingLayer.style.display = showLayer4.checked ? 'block' : 'none';

            // Layer 4: Decoration sub-option (dark background)
            const darkBg = document.getElementById('toggle-dark-background');
            if (showLayer4 && darkBg) {
                const isLayer4Enabled = showLayer4.checked;
                darkBg.disabled = !isLayer4Enabled;
                darkBg.parentElement.style.opacity = isLayer4Enabled ? '1' : '0.5';

                const svgContainer = document.getElementById('svg-container');
                svgContainer.style.background = darkBg.checked ? '#2a2a2a' : 'white';
            }

            // Error layer
            const showErrors = document.getElementById('show-errors');
            if (showErrors) errorLayer.style.display = showErrors.checked ? 'block' : 'none';
        };

        applyCheckboxStates();

        // Try to load cached algorithm results
        const hasCachedResults = loadAlgorithmResults();
        if (hasCachedResults) {
            // Draw algorithm display layers with cached data
            drawAlgorithmResult();
            drawAlgorithmDisplay();
            createWhiteRingMask();
            drawWhiteRings();

            // Auto-enable algorithm layer checkbox
            document.getElementById('show-layer-3-algorithm').checked = true;

            // Show algorithm stats if available
            if (algorithmStats) {
                const statsDiv = document.getElementById('algorithm-stats');
                let statsHTML = `
                    <strong>ç®—æ³•ç»Ÿè®¡ï¼ˆçº¯æ‰‡ç¯ï¼‰ï¼š</strong><br>
                    â€¢ æ€»æ‰‡ç¯æ•°ï¼š${algorithmStats.totalSectors}<br>
                    â€¢ å•è‰²æ‰‡ç¯ï¼š${algorithmStats.sameColorSectors}<br>
                    â€¢ æ··è‰²æ‰‡ç¯ï¼š${algorithmStats.mixedColorSectors}<br>
                    â€¢ è€—æ—¶ï¼š${algorithmStats.elapsedSeconds} ç§’<br>
                `;

                statsHTML += `
                    <br>
                    <strong>é¢œè‰²è¯´æ˜ï¼ˆä¸‰åŸè‰²ï¼‰ï¼š</strong><br>
                    â€¢ ğŸ”´ çº¢è‰²ï¼šåŸå§‹æ–¹å½¢ç ç‚¹<br>
                    â€¢ ğŸ”µ è“è‰²ï¼šäººå·¥æ‰‡ç¯å›¾åƒ<br>
                    â€¢ ğŸŸ¢ ç»¿è‰²ï¼šç®—æ³•æ‰‡ç¯å›¾åƒ<br>
                    â€¢ âšª ç™½è‰²ï¼šç•™ç©ºï¼ˆä¸æ˜¾ç¤ºï¼‰
                `;

                statsDiv.innerHTML = statsHTML;
                statsDiv.style.display = 'block';

                console.log('[Init] âœ… Restored algorithm display from cache');
            }

            // Update button text to indicate re-run
            const runButton = document.getElementById('run-algorithm');
            runButton.textContent = 'é‡æ–°è¿è¡Œç®—æ³• (Re-run Algorithm)';
        }

        // éšè—æ—§çš„è°ƒè¯•å›¾å±‚
        moduleLayer.style.display = 'none';
        algorithmLayer.style.display = 'none';

        // å›¾å±‚è®¾è®¡çš„åˆå§‹æ˜¾ç¤ºçŠ¶æ€ - æ ¹æ® checkbox çŠ¶æ€ï¼ˆå¯èƒ½ä» localStorage åŠ è½½ï¼‰
        // Layer 1: Original QR
        const showLayer1Checkbox = document.getElementById('show-layer-1-original');
        originalDisplayLayer.style.display = showLayer1Checkbox.checked ? 'block' : 'none';

        // Layer 3: Algorithm - æ ¹æ®ç¼“å­˜å’Œ checkbox çŠ¶æ€å†³å®š
        const showLayer3Checkbox = document.getElementById('show-layer-3-algorithm');
        if (hasCachedResults && showLayer3Checkbox.checked) {
            algorithmDisplayLayer.style.display = 'block';
        } else {
            algorithmDisplayLayer.style.display = 'none';
        }

        // Layer 4: Decoration (white rings) - æ ¹æ® checkbox çŠ¶æ€
        const showLayer4Checkbox = document.getElementById('show-layer-4-decoration');
        whiteRingLayer.style.display = showLayer4Checkbox.checked ? 'block' : 'none';

        // Error layer - æ ¹æ® checkbox çŠ¶æ€
        const showErrorsCheckbox = document.getElementById('show-errors');
        errorLayer.style.display = showErrorsCheckbox.checked ? 'block' : 'none';

        // Toggle controls for auxiliary layer 2.5
        const showGrid = document.getElementById('show-grid');
        const showCircles = document.getElementById('show-circles');
        const showRadials = document.getElementById('show-radials');
        const showAuxiliary = document.getElementById('show-layer-2.5-auxiliary');

        // Master checkbox for Layer 2.5
        showAuxiliary.addEventListener('change', (e) => {
            const isChecked = e.target.checked;

            // Toggle visibility of all three sub-layers
            gridLayer.style.display = isChecked && showGrid.checked ? 'block' : 'none';
            circleLayer.style.display = isChecked && showCircles.checked ? 'block' : 'none';
            radialLayer.style.display = isChecked && showRadials.checked ? 'block' : 'none';

            // Enable/disable sub-checkboxes
            showGrid.disabled = !isChecked;
            showCircles.disabled = !isChecked;
            showRadials.disabled = !isChecked;

            // Gray out labels when disabled
            showGrid.parentElement.style.opacity = isChecked ? '1' : '0.5';
            showCircles.parentElement.style.opacity = isChecked ? '1' : '0.5';
            showRadials.parentElement.style.opacity = isChecked ? '1' : '0.5';
        });

        // Individual sub-layer controls
        showGrid.addEventListener('change', (e) => {
            if (showAuxiliary.checked) {
                gridLayer.style.display = e.target.checked ? 'block' : 'none';
            }
        });

        showCircles.addEventListener('change', (e) => {
            if (showAuxiliary.checked) {
                circleLayer.style.display = e.target.checked ? 'block' : 'none';
            }
        });

        showRadials.addEventListener('change', (e) => {
            if (showAuxiliary.checked) {
                radialLayer.style.display = e.target.checked ? 'block' : 'none';
            }
        });

        // show-modules removed - now using show-original for originalDisplayLayer
        // show-white-rings removed - now using show-layer-4-decoration for whiteRingLayer

        // Layer controls (ä¸‰åŸè‰²å›¾å±‚æ§åˆ¶ - æ§åˆ¶æ–°çš„ç‹¬ç«‹æ˜¾ç¤ºå›¾å±‚)
        // Four-layer visibility controls
        document.getElementById('show-layer-1-original').addEventListener('change', (e) => {
            originalDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-layer-3-algorithm').addEventListener('change', async (e) => {
            // If checking the box and algorithm hasn't run yet, run it first
            if (e.target.checked && Object.keys(sectorColors).length === 0) {
                console.log('[Layer Control] Algorithm not run yet, running automatically...');

                // Uncheck temporarily while running
                e.target.checked = false;

                // Trigger algorithm run
                const button = document.getElementById('run-algorithm');
                const statsDiv = document.getElementById('algorithm-stats');

                button.disabled = true;
                button.textContent = 'è¿è¡Œä¸­... (Running...)';
                statsDiv.style.display = 'none';

                try {
                    const stats = await runConversionAlgorithm();
                    drawAlgorithmResult();
                    drawAlgorithmDisplay();

                    // Update white ring mask to match algorithm data
                    createWhiteRingMask();
                    drawWhiteRings();

                    // Show stats
                    let statsHTML = `
                        <strong>ç®—æ³•ç»Ÿè®¡ï¼ˆçº¯æ‰‡ç¯ï¼‰ï¼š</strong><br>
                        â€¢ æ€»æ‰‡ç¯æ•°ï¼š${stats.totalSectors}<br>
                        â€¢ å•è‰²æ‰‡ç¯ï¼š${stats.sameColorSectors}<br>
                        â€¢ æ··è‰²æ‰‡ç¯ï¼š${stats.mixedColorSectors}<br>
                        â€¢ è€—æ—¶ï¼š${stats.elapsedSeconds} ç§’<br>
                    `;

                    statsHTML += `
                        <br>
                        <strong>é¢œè‰²è¯´æ˜ï¼ˆä¸‰åŸè‰²ï¼‰ï¼š</strong><br>
                        â€¢ ğŸ”´ çº¢è‰²ï¼šåŸå§‹æ–¹å½¢ç ç‚¹<br>
                        â€¢ ğŸ”µ è“è‰²ï¼šäººå·¥æ‰‡ç¯å›¾åƒ<br>
                        â€¢ ğŸŸ¢ ç»¿è‰²ï¼šç®—æ³•æ‰‡ç¯å›¾åƒ<br>
                        â€¢ âšª ç™½è‰²ï¼šç•™ç©ºï¼ˆä¸æ˜¾ç¤ºï¼‰
                    `;

                    statsDiv.innerHTML = statsHTML;
                    statsDiv.style.display = 'block';

                    // Now check the box and show layer
                    e.target.checked = true;
                    algorithmDisplayLayer.style.display = 'block';

                    console.log('[Algorithm] âœ… Completed successfully! Algorithm layer is now visible.');
                } catch (error) {
                    console.error('[Algorithm] Error:', error);
                    alert('ç®—æ³•æ‰§è¡Œå¤±è´¥ï¼š' + error.message);
                } finally {
                    button.disabled = false;
                    button.textContent = 'é‡æ–°è¿è¡Œç®—æ³• (Re-run Algorithm)';
                }
            } else {
                // Normal toggle behavior
                algorithmDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
            }

            // Enable/disable sub-checkboxes based on parent state
            const isChecked = e.target.checked;
            const edgeExt = document.getElementById('toggle-edge-extension');
            const coverageOpt = document.getElementById('toggle-coverage-optimization');
            edgeExt.disabled = !isChecked;
            coverageOpt.disabled = !isChecked;
            edgeExt.parentElement.style.opacity = isChecked ? '1' : '0.5';
            coverageOpt.parentElement.style.opacity = isChecked ? '1' : '0.5';
        });

        document.getElementById('show-layer-4-decoration').addEventListener('change', (e) => {
            whiteRingLayer.style.display = e.target.checked ? 'block' : 'none';

            // Enable/disable sub-checkbox based on parent state
            const isChecked = e.target.checked;
            const darkBgCheckbox = document.getElementById('toggle-dark-background');
            darkBgCheckbox.disabled = !isChecked;
            darkBgCheckbox.parentElement.style.opacity = isChecked ? '1' : '0.5';

            // Debug: log white ring layer status
            console.log('[Layer 4 Decoration] Toggled:', e.target.checked);
            console.log('[Layer 4 Decoration] Layer element:', whiteRingLayer);
            console.log('[Layer 4 Decoration] Layer children count:', whiteRingLayer.children.length);
            console.log('[Layer 4 Decoration] Layer innerHTML length:', whiteRingLayer.innerHTML.length);
            console.log('[Layer 4 Decoration] Layer mask attribute:', whiteRingLayer.getAttribute('mask'));

            // Check if mask exists
            const mask = document.getElementById('white-ring-mask');
            console.log('[Layer 4 Decoration] Mask element:', mask);
            if (mask) {
                console.log('[Layer 4 Decoration] Mask children count:', mask.children.length);
                console.log('[Layer 4 Decoration] Mask innerHTML:', mask.innerHTML.substring(0, 500));
            }
        });

        // Dark background toggle (for viewing white rings)
        document.getElementById('toggle-dark-background').addEventListener('change', (e) => {
            const svgContainer = document.getElementById('svg-container');
            if (e.target.checked) {
                svgContainer.style.background = '#2a2a2a'; // Dark gray background
                console.log('[Background] Switched to dark background');
            } else {
                svgContainer.style.background = 'white'; // White background
                console.log('[Background] Switched to white background');
            }
        });

        // White ring stroke width control
        document.getElementById('white-ring-width').addEventListener('input', (e) => {
            whiteRingStrokeWidth = parseFloat(e.target.value);
            document.getElementById('white-ring-width-value').textContent = whiteRingStrokeWidth.toFixed(1);

            // Redraw white rings with new width
            drawWhiteRings();

            console.log(`[White Ring Width] Changed to ${whiteRingStrokeWidth}`);
        });

        // Finder pattern parameter controls
        function redrawAllPatterns() {
            // Redraw original display (red layer)
            drawOriginalDisplay();
            // Redraw algorithm display (green layer) if algorithm has run
            if (Object.keys(sectorColors).length > 0) {
                drawAlgorithmDisplay();
            }
        }

        document.getElementById('finder-outer-radius').addEventListener('input', (e) => {
            finderOuterRadius = parseFloat(e.target.value);
            document.getElementById('finder-outer-radius-value').textContent = finderOuterRadius.toFixed(1);
            redrawAllPatterns();
            saveCheckboxStates(); // Save slider values too
        });

        document.getElementById('finder-ring-width').addEventListener('input', (e) => {
            finderRingWidth = parseFloat(e.target.value);
            document.getElementById('finder-ring-width-value').textContent = finderRingWidth.toFixed(1);
            redrawAllPatterns();
            saveCheckboxStates();
        });

        document.getElementById('finder-center-radius').addEventListener('input', (e) => {
            finderCenterRadius = parseFloat(e.target.value);
            document.getElementById('finder-center-radius-value').textContent = finderCenterRadius.toFixed(1);
            redrawAllPatterns();
            saveCheckboxStates();
        });

        document.getElementById('alignment-center-radius').addEventListener('input', (e) => {
            alignmentCenterRadius = parseFloat(e.target.value);
            document.getElementById('alignment-center-radius-value').textContent = alignmentCenterRadius.toFixed(1);
            redrawAllPatterns();
            saveCheckboxStates();
        });

        // Edge extension toggle
        document.getElementById('toggle-edge-extension').addEventListener('change', (e) => {
            edgeExtensionEnabled = e.target.checked;

            // If edge extension is disabled, also disable coverage optimization
            if (!edgeExtensionEnabled && coverageOptimizationEnabled) {
                coverageOptimizationEnabled = false;
                document.getElementById('toggle-coverage-optimization').checked = false;
            }

            console.log(`[Edge Extension] Toggle: ${edgeExtensionEnabled ? 'ENABLED' : 'DISABLED'}`);

            // Redraw if algorithm has been run
            if (Object.keys(sectorColors).length > 0) {
                drawAlgorithmDisplay();

                // Update white ring mask to match new data source
                createWhiteRingMask();
                drawWhiteRings();

                // If error layer is visible, re-run coverage detection with new data source
                const showErrorsCheckbox = document.getElementById('show-errors');
                if (showErrorsCheckbox && showErrorsCheckbox.checked) {
                    console.log('[Edge Extension] Re-running coverage detection with new data source...');
                    const checkAlgorithm = algorithmDisplayLayer.style.display !== 'none';
                    const errors = detectCoverageErrors(checkAlgorithm);
                    drawErrorMarkers(errors);
                }
            }
        });

        // Coverage optimization toggle
        document.getElementById('toggle-coverage-optimization').addEventListener('change', (e) => {
            // Coverage optimization requires edge extension to be enabled
            if (e.target.checked && !edgeExtensionEnabled) {
                edgeExtensionEnabled = true;
                document.getElementById('toggle-edge-extension').checked = true;
                console.log('[Coverage Opt] Auto-enabled edge extension (required)');
            }

            coverageOptimizationEnabled = e.target.checked;
            console.log(`[Coverage Opt] Toggle: ${coverageOptimizationEnabled ? 'ENABLED' : 'DISABLED'}`);

            // Redraw if algorithm has been run
            if (Object.keys(sectorColors).length > 0) {
                drawAlgorithmDisplay();

                // Update white ring mask to match new data source
                createWhiteRingMask();
                drawWhiteRings();

                // If error layer is visible, re-run coverage detection with new data source
                const showErrorsCheckbox = document.getElementById('show-errors');
                if (showErrorsCheckbox && showErrorsCheckbox.checked) {
                    console.log('[Coverage Opt] Re-running coverage detection with new data source...');
                    const checkAlgorithm = algorithmDisplayLayer.style.display !== 'none';
                    const errors = detectCoverageErrors(checkAlgorithm);
                    drawErrorMarkers(errors);
                }
            }
        });

        // Coverage detection controls
        document.getElementById('show-errors').addEventListener('change', (e) => {
            errorLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        // Auto-save all checkbox states when any checkbox changes
        document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
            checkbox.addEventListener('change', () => {
                saveCheckboxStates();
            });
        });
        console.log('[Checkbox Cache] âœ… Auto-save enabled for all checkboxes');

        document.getElementById('run-detection').addEventListener('click', () => {
            const button = document.getElementById('run-detection');
            const statsDiv = document.getElementById('detection-stats');
            const checkbox = document.getElementById('show-errors');

            button.disabled = true;
            button.textContent = 'æ£€æµ‹ä¸­... (Detecting...)';
            statsDiv.style.display = 'none';

            // Check if algorithm layer is currently displayed
            const checkAlgorithm = algorithmDisplayLayer.style.display !== 'none';

            if (!checkAlgorithm) {
                alert('è¯·å…ˆå‹¾é€‰ç®—æ³•æ‰‡ç¯å›¾å±‚ï¼');
                button.disabled = false;
                button.textContent = 'æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)';
                return;
            }

            // Run detection in next frame to allow UI update
            setTimeout(() => {
                try {
                    const errors = detectCoverageErrors(checkAlgorithm);
                    drawErrorMarkers(errors);

                    // Show stats
                    const totalBlackModules = Object.values(baseModuleState).filter(v => v).length;
                    const errorRate = ((errors.length / totalBlackModules) * 100).toFixed(1);

                    let statsHTML = `
                        <strong>æ£€æµ‹ç»“æœï¼š</strong><br>
                        â€¢ æ€»é»‘è‰²ç ç‚¹ï¼š${totalBlackModules}<br>
                        â€¢ è¦†ç›–ä¸è¶³ï¼ˆ<${MIN_BLACK_COVERAGE * 100}%ï¼‰ï¼š${errors.length}<br>
                        â€¢ é”™è¯¯ç‡ï¼š${errorRate}%<br>
                        <br>
                        <strong>æ£€æµ‹èŒƒå›´ï¼š</strong><br>
                        ${checkAlgorithm ? 'âœ“ ç®—æ³•æ‰‡ç¯å±‚<br>' : ''}
                    `;

                    statsDiv.innerHTML = statsHTML;
                    statsDiv.style.display = 'block';

                    // Auto enable error display
                    if (errors.length > 0) {
                        checkbox.checked = true;
                        errorLayer.style.display = 'block';
                    }

                    alert(`æ£€æµ‹å®Œæˆï¼\nå‘ç° ${errors.length} ä¸ªè¦†ç›–ä¸è¶³çš„ç ç‚¹ï¼ˆ<${MIN_BLACK_COVERAGE * 100}%ï¼‰\né”™è¯¯ç‡ï¼š${errorRate}%`);
                } catch (error) {
                    console.error('[Detection] Error:', error);
                    alert('æ£€æµ‹å¤±è´¥ï¼š' + error.message);
                } finally {
                    button.disabled = false;
                    button.textContent = 'æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)';
                }
            }, 10);
        });

        // QR Recognition Test
        document.getElementById('test-qr').addEventListener('click', async () => {
            const button = document.getElementById('test-qr');
            const statusLight = document.getElementById('qr-status-light');
            const statusText = document.getElementById('qr-status-text');
            const resultDiv = document.getElementById('qr-result');

            button.disabled = true;
            button.textContent = 'è¯†åˆ«ä¸­... (Testing...)';
            statusLight.style.background = '#FFA500'; // Orange
            statusText.textContent = 'è¯†åˆ«ä¸­...';
            resultDiv.style.display = 'none';

            try {
                // Temporarily hide auxiliary debug layers (2.5) for clean QR recognition
                const savedGridDisplay = gridLayer.style.display;
                const savedCircleDisplay = circleLayer.style.display;
                const savedRadialDisplay = radialLayer.style.display;
                const savedWhiteRingDisplay = whiteRingLayer.style.display;
                const savedErrorDisplay = errorLayer.style.display;

                gridLayer.style.display = 'none';
                circleLayer.style.display = 'none';
                radialLayer.style.display = 'none';
                whiteRingLayer.style.display = 'none';
                errorLayer.style.display = 'none';

                console.log('[QR Test] Temporarily hiding auxiliary layers (grid, circles, radials, white rings, errors)');

                // Get the SVG element
                const svgElement = svg;
                const svgRect = svgElement.getBoundingClientRect();

                // Create a canvas to render the SVG
                const canvas = document.createElement('canvas');
                const scale = 2; // Higher resolution for better recognition
                canvas.width = svgRect.width * scale;
                canvas.height = svgRect.height * scale;
                const ctx = canvas.getContext('2d');

                // Convert SVG to image
                const svgData = new XMLSerializer().serializeToString(svgElement);
                const img = new Image();
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                img.onload = () => {
                    // Draw image on canvas
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    URL.revokeObjectURL(url);

                    // Get image data for jsQR
                    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                    // Try to decode QR code
                    const code = jsQR(imageData.data, imageData.width, imageData.height, {
                        inversionAttempts: "dontInvert"
                    });

                    if (code) {
                        // Success
                        statusLight.style.background = '#4CAF50'; // Green
                        statusLight.style.boxShadow = '0 0 10px #4CAF50';
                        statusText.textContent = 'è¯†åˆ«æˆåŠŸï¼';
                        statusText.style.color = '#4CAF50';

                        resultDiv.innerHTML = `
                            <strong>è¯†åˆ«ç»“æœï¼š</strong><br>
                            <div style="background: #e8f5e9; padding: 8px; border-radius: 4px; margin-top: 5px; word-break: break-all;">
                                ${code.data}
                            </div>
                        `;
                        resultDiv.style.display = 'block';

                        console.log('[QR Test] Success:', code.data);
                    } else {
                        // Failed
                        statusLight.style.background = '#f44336'; // Red
                        statusLight.style.boxShadow = '0 0 10px #f44336';
                        statusText.textContent = 'è¯†åˆ«å¤±è´¥';
                        statusText.style.color = '#f44336';

                        resultDiv.innerHTML = `
                            <strong>è¯†åˆ«å¤±è´¥</strong><br>
                            <span style="color: #666; font-size: 11px;">
                                å¯èƒ½åŸå› ï¼š<br>
                                â€¢ QR ç å˜å½¢è¿‡åº¦<br>
                                â€¢ å›¾å±‚é®æŒ¡ï¼ˆæ£€æŸ¥å›¾å±‚æ§åˆ¶ï¼‰<br>
                                â€¢ éœ€è¦è°ƒæ•´é®ç½©æˆ–ç®—æ³•
                            </span>
                        `;
                        resultDiv.style.display = 'block';

                        console.log('[QR Test] Failed to recognize QR code');
                    }

                    // Restore auxiliary layers
                    gridLayer.style.display = savedGridDisplay;
                    circleLayer.style.display = savedCircleDisplay;
                    radialLayer.style.display = savedRadialDisplay;
                    whiteRingLayer.style.display = savedWhiteRingDisplay;
                    errorLayer.style.display = savedErrorDisplay;
                    console.log('[QR Test] Restored auxiliary layers');

                    button.disabled = false;
                    button.textContent = 'æµ‹è¯•è¯†åˆ« (Test QR)';
                };

                img.onerror = () => {
                    // Restore auxiliary layers
                    gridLayer.style.display = savedGridDisplay;
                    circleLayer.style.display = savedCircleDisplay;
                    radialLayer.style.display = savedRadialDisplay;
                    whiteRingLayer.style.display = savedWhiteRingDisplay;
                    errorLayer.style.display = savedErrorDisplay;

                    statusLight.style.background = '#f44336'; // Red
                    statusText.textContent = 'åŠ è½½å¤±è´¥';
                    statusText.style.color = '#f44336';
                    button.disabled = false;
                    button.textContent = 'æµ‹è¯•è¯†åˆ« (Test QR)';
                    alert('å›¾åƒåŠ è½½å¤±è´¥');
                };

                img.src = url;

            } catch (error) {
                console.error('[QR Test] Error:', error);

                // Restore auxiliary layers if error occurs
                try {
                    gridLayer.style.display = savedGridDisplay;
                    circleLayer.style.display = savedCircleDisplay;
                    radialLayer.style.display = savedRadialDisplay;
                    whiteRingLayer.style.display = savedWhiteRingDisplay;
                    errorLayer.style.display = savedErrorDisplay;
                } catch (e) {
                    // Ignore restoration errors
                }

                statusLight.style.background = '#f44336'; // Red
                statusText.textContent = 'æµ‹è¯•å¤±è´¥';
                statusText.style.color = '#f44336';
                button.disabled = false;
                button.textContent = 'æµ‹è¯•è¯†åˆ« (Test QR)';
                alert('æµ‹è¯•å¤±è´¥ï¼š' + error.message);
            }
        });

        // Algorithm controls
        document.getElementById('run-algorithm').addEventListener('click', async () => {
            const button = document.getElementById('run-algorithm');
            const statsDiv = document.getElementById('algorithm-stats');
            const checkbox = document.getElementById('show-algorithm');

            button.disabled = true;
            button.textContent = 'è¿è¡Œä¸­... (Running...)';
            statsDiv.style.display = 'none';

            try {
                const stats = await runConversionAlgorithm();
                drawAlgorithmResult();
                drawAlgorithmDisplay(); // Draw on new independent display layer

                // Update white ring mask to match algorithm data
                createWhiteRingMask();
                drawWhiteRings();

                // Show stats
                let statsHTML = `
                    <strong>ç®—æ³•ç»Ÿè®¡ï¼ˆçº¯æ‰‡ç¯ï¼‰ï¼š</strong><br>
                    â€¢ æ€»æ‰‡ç¯æ•°ï¼š${stats.totalSectors}<br>
                    â€¢ å•è‰²æ‰‡ç¯ï¼š${stats.sameColorSectors}<br>
                    â€¢ æ··è‰²æ‰‡ç¯ï¼š${stats.mixedColorSectors}<br>
                    â€¢ è€—æ—¶ï¼š${stats.elapsedSeconds} ç§’<br>
                `;

                statsHTML += `
                    <br>
                    <strong>é¢œè‰²è¯´æ˜ï¼ˆä¸‰åŸè‰²ï¼‰ï¼š</strong><br>
                    â€¢ ğŸ”´ çº¢è‰²ï¼šåŸå§‹æ–¹å½¢ç ç‚¹<br>
                    â€¢ ğŸ”µ è“è‰²ï¼šäººå·¥æ‰‡ç¯å›¾åƒ<br>
                    â€¢ ğŸŸ¢ ç»¿è‰²ï¼šç®—æ³•æ‰‡ç¯å›¾åƒ<br>
                    â€¢ âšª ç™½è‰²ï¼šç•™ç©ºï¼ˆä¸æ˜¾ç¤ºï¼‰
                `;

                statsDiv.innerHTML = statsHTML;
                statsDiv.style.display = 'block';

                // Auto enable algorithm layer display (no alert on success)
                document.getElementById('show-layer-3-algorithm').checked = true;
                algorithmDisplayLayer.style.display = 'block';

                console.log('[Algorithm] âœ… Completed successfully! Algorithm layer is now visible.');
            } catch (error) {
                console.error('[Algorithm] Error:', error);
                alert('ç®—æ³•æ‰§è¡Œå¤±è´¥ï¼š' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'é‡æ–°è¿è¡Œç®—æ³• (Re-run Algorithm)';
            }
        });

        // Debug sector button
        document.getElementById('debug-sector').addEventListener('click', () => {
            const radial = parseInt(prompt('è¾“å…¥ radial index (0-119):', '30'));
            const ring = parseInt(prompt('è¾“å…¥ ring index (0-30):', '5'));

            if (isNaN(radial) || isNaN(ring)) {
                alert('æ— æ•ˆçš„è¾“å…¥');
                return;
            }

            console.log('========================================');
            console.log(`ğŸ” è°ƒè¯•æ‰‡ç¯: radial=${radial}, ring=${ring}`);
            console.log('========================================');

            // Call with debug flag
            const color = calculateSectorColor_Simplified(radial, ring, true);

            // Check algorithm result
            const algoEdits = [];
            for (const [cellId, state] of Object.entries(algorithmState)) {
                if (cellId.includes(`radial:${radial}|ring:${ring}`)) {
                    algoEdits.push({ cellId, state });
                }
            }

            console.log('ğŸ¤– ç®—æ³•ç»“æœ:', algoEdits.length > 0 ? algoEdits : 'æ— ');
            console.log('========================================');

            alert(`è°ƒè¯•å®Œæˆï¼\nè¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºã€‚\n\næ‰‡ç¯é¢œè‰²: ${color ? 'é»‘è‰²' : 'ç™½è‰²'}\nç®—æ³•ç»“æœ: ${algoEdits.length} ä¸ª`);
        });

        // Download QR code as pure black/white image - directly from SVG
        document.getElementById('download-qr').addEventListener('click', async () => {
            // Check if algorithm has been run
            if (Object.keys(sectorColors).length === 0) {
                alert('è¯·å…ˆè¿è¡Œç®—æ³•ç”ŸæˆäºŒç»´ç ï¼');
                return;
            }

            console.log('[Download] Converting SVG to black/white PNG...');

            // Choose filename based on optimization toggles
            let filename = 'qr-algorithm';
            if (coverageOptimizationEnabled) {
                filename = 'qr-optimized';
            } else if (edgeExtensionEnabled) {
                filename = 'qr-edge-extended';
            }

            // Clone the SVG for processing
            const svgClone = svg.cloneNode(true);

            // Store original display states
            const layerStates = {
                original: document.getElementById('show-layer-1-original').checked,
                grid: document.getElementById('show-grid').checked,
                circles: document.getElementById('show-circles').checked,
                radial: document.getElementById('show-radials').checked,
                algorithm: document.getElementById('show-layer-3-algorithm').checked,
                decoration: document.getElementById('show-layer-4-decoration').checked
            };

            console.log('[Download] Current layer states:', layerStates);

            // Get all layers from cloned SVG
            const layers = {
                original: svgClone.querySelector('#layer-1-original'),
                grid: svgClone.querySelector('#grid-layer'),
                circles: svgClone.querySelector('#circle-layer'),
                radial: svgClone.querySelector('#radial-layer'),
                algorithm: svgClone.querySelector('#layer-3-algorithm'),
                decoration: svgClone.querySelector('#white-ring-layer'),
                error: svgClone.querySelector('#error-layer')
            };

            // Hide layers that should not be in the download
            if (layers.original) layers.original.style.display = 'none'; // Always hide original (red) layer
            if (layers.error) layers.error.style.display = 'none'; // Always hide error highlights
            if (layers.grid) layers.grid.style.display = 'none'; // Hide debug grid
            if (layers.circles) layers.circles.style.display = 'none'; // Hide debug circles
            if (layers.radial) layers.radial.style.display = 'none'; // Hide debug radial lines

            if (layers.algorithm && layerStates.algorithm) {
                layers.algorithm.style.display = 'block';
            } else if (layers.algorithm) {
                layers.algorithm.style.display = 'none';
            }

            if (layers.decoration && layerStates.decoration) {
                layers.decoration.style.display = 'block';
            } else if (layers.decoration) {
                layers.decoration.style.display = 'none';
            }

            // Convert colors to pure black/white
            // Green (#00ff00) -> Black
            // Red (#ff0000) -> Black
            // White (#ffffff) -> White
            const allElements = svgClone.querySelectorAll('*');
            allElements.forEach(el => {
                // Convert fill colors
                const fill = el.getAttribute('fill');
                if (fill && fill !== 'none') {
                    // Convert any non-white color to black
                    if (fill.toLowerCase() !== '#ffffff' && fill.toLowerCase() !== 'white') {
                        el.setAttribute('fill', 'black');
                    } else {
                        el.setAttribute('fill', 'white');
                    }
                }

                // Convert stroke colors
                const stroke = el.getAttribute('stroke');
                if (stroke && stroke !== 'none') {
                    // Keep white strokes white, convert others to black
                    if (stroke.toLowerCase() !== '#ffffff' && stroke.toLowerCase() !== 'white') {
                        el.setAttribute('stroke', 'black');
                    } else {
                        el.setAttribute('stroke', 'white');
                    }
                }

                // Set full opacity for all visible elements
                if (el.getAttribute('opacity')) {
                    el.setAttribute('opacity', '1');
                }
            });

            // Serialize SVG to string
            const serializer = new XMLSerializer();
            let svgString = serializer.serializeToString(svgClone);

            // Add white background
            svgString = svgString.replace(
                '<svg',
                '<svg style="background-color: white;"'
            );

            // Create blob and data URL
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const svgUrl = URL.createObjectURL(svgBlob);

            // Create image from SVG
            const img = new Image();
            img.onload = () => {
                // Create high-resolution canvas
                const exportSize = 2000; // 2000x2000 px for high quality
                const canvas = document.createElement('canvas');
                canvas.width = exportSize;
                canvas.height = exportSize;
                const ctx = canvas.getContext('2d', {
                    alpha: false,
                    willReadFrequently: false
                });

                // Enable anti-aliasing
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';

                // Fill white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, exportSize, exportSize);

                // Draw SVG image
                ctx.drawImage(img, 0, 0, exportSize, exportSize);

                // Clean up
                URL.revokeObjectURL(svgUrl);

                // Convert to PNG and download
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${filename}.png`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    console.log(`[Download] âœ… Downloaded as ${filename}.png (${exportSize}Ã—${exportSize}px)`);
                    console.log(`[Download] Included layers: algorithm=${layerStates.algorithm}, decoration=${layerStates.decoration}`);
                }, 'image/png');
            };

            img.onerror = () => {
                URL.revokeObjectURL(svgUrl);
                alert('ä¸‹è½½å¤±è´¥ï¼šæ— æ³•è½¬æ¢ SVG');
                console.error('[Download] Failed to load SVG image');
            };

            img.src = svgUrl;
        });

        // Mouse wheel zoom (zoom centered on cursor, limited to 50%-200%)
    </script>
</body>
</html>
