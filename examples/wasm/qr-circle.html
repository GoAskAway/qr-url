<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR Circle Debug Tool</title>
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: monospace;
            background: #f5f5f5;
            overflow: hidden;
        }

        #container {
            display: flex;
            height: 100vh;
            background: white;
        }

        #left-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow: auto;
        }

        #right-panel {
            width: 350px;
            padding: 20px;
            background: #fafafa;
            border-left: 1px solid #ddd;
            overflow-y: auto;
        }

        h1 {
            margin: 0 0 20px 0;
            font-size: 24px;
        }

        #svg-container {
            border: 1px solid #ddd;
            background: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex: 1;
        }

        svg {
            display: block;
        }

        .controls {
            margin: 0;
        }

        .control-group {
            margin: 15px 0;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .control-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
        }

        input[type="range"] {
            width: 100%;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .slider-label span {
            font-weight: bold;
            color: #2196F3;
        }

        .info {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 4px;
            font-size: 13px;
            line-height: 1.6;
            border: 1px solid #ffc107;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            margin: 20px 0 10px 0;
            padding-bottom: 5px;
            border-bottom: 2px solid #2196F3;
        }

        @media print {
            body {
                background: white;
                overflow: visible;
            }

            #container {
                display: block;
                height: auto;
            }

            #left-panel {
                padding: 0;
                overflow: visible;
                display: flex;
                align-items: center;
                justify-content: center;
                min-height: 100vh;
            }

            #right-panel {
                display: none;
            }

            h1 {
                display: none;
            }

            #svg-container {
                border: none;
                flex: none;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="left-panel">
            <h1>QR Circle Debug Tool - 21Ã—21 Grid</h1>
            <div id="svg-container"></div>
        </div>

        <div id="right-panel">
            <div class="section-title">æ˜¾ç¤ºé€‰é¡¹</div>
            <div class="controls">
                <div class="control-group">
                    <label><input type="checkbox" id="show-grid" checked> æ˜¾ç¤ºåº•æ ¼ï¼ˆç½‘æ ¼çº¿ï¼‰</label>
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="show-circles" checked> æ˜¾ç¤ºåœ†ç¯ï¼ˆæ¯0.5å•ä½ï¼‰</label>
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="show-radials" checked> æ˜¾ç¤ºæ”¾å°„çº¿ï¼ˆæ¯3Â°ï¼‰</label>
                </div>
                <div class="control-group">
                    <label><input type="checkbox" id="show-white-rings"> æ˜¾ç¤ºç™½è‰²ç¯çº¿</label>
                </div>
            </div>

            <div class="section-title">è§†å›¾æ§åˆ¶</div>
            <div class="controls">
                <div class="control-group">
                    <button id="reset-view" style="width: 100%; padding: 10px; cursor: pointer; background: #2196F3; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        é‡ç½®è§†å›¾ (Reset View)
                    </button>
                </div>
                <div class="control-group">
                    <button id="clear-modifications" style="width: 100%; padding: 10px; cursor: pointer; background: #f44336; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æ¸…é™¤æ‰€æœ‰ä¿®æ”¹ (Clear All)
                    </button>
                </div>
                <div class="control-group">
                    <button id="export-settings" style="width: 100%; padding: 10px; cursor: pointer; background: #FF9800; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        å¯¼å‡ºè®¾ç½® (Export)
                    </button>
                </div>
                <div class="control-group">
                    <input type="file" id="import-file" accept=".json" style="display: none;">
                    <button id="import-settings" style="width: 100%; padding: 10px; cursor: pointer; background: #9C27B0; color: white; border: none; border-radius: 4px; font-size: 14px;">
                        å¯¼å…¥è®¾ç½® (Import)
                    </button>
                </div>
            </div>

            <div class="section-title">QR è¯†åˆ«æµ‹è¯•</div>
            <div class="controls">
                <div class="control-group">
                    <button id="test-qr" style="width: 100%; padding: 10px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æµ‹è¯•è¯†åˆ« (Test QR)
                    </button>
                </div>
                <div class="control-group" style="display: flex; align-items: center; gap: 10px;">
                    <div id="qr-status-light" style="width: 24px; height: 24px; border-radius: 50%; background: #999; border: 2px solid #666; box-shadow: inset 0 0 5px rgba(0,0,0,0.3);"></div>
                    <span id="qr-status-text" style="font-size: 14px; color: #666;">æœªæµ‹è¯•</span>
                </div>
                <div id="qr-result" style="margin-top: 10px; padding: 10px; background: #f0f0f0; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="section-title">å›¾å±‚æ§åˆ¶ï¼ˆä¸‰åŸè‰²ï¼‰</div>
            <div class="controls">
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-original" checked>
                        <span style="color: #FF0000; font-weight: bold;">ğŸ”´ åŸå§‹æ–¹å½¢ç ç‚¹</span>
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-manual" checked>
                        <span style="color: #0000FF; font-weight: bold;">ğŸ”µ äººå·¥æ‰‡ç¯å›¾åƒ</span>
                    </label>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-algorithm">
                        <span style="color: #00FF00; font-weight: bold;">ğŸŸ¢ ç®—æ³•æ‰‡ç¯å›¾åƒ</span>
                    </label>
                </div>
            </div>

            <div class="section-title">è¦†ç›–ç‡æ£€æµ‹</div>
            <div class="controls">
                <div class="control-group">
                    <button id="run-detection" style="width: 100%; padding: 10px; cursor: pointer; background: #FF5722; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)
                    </button>
                </div>
                <div class="control-group">
                    <label>
                        <input type="checkbox" id="show-errors">
                        <span style="color: #FF0000; font-weight: bold;">æ˜¾ç¤ºé”™è¯¯æ ‡è®°</span>
                    </label>
                </div>
                <div id="detection-stats" style="margin-top: 10px; padding: 10px; background: #ffebee; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="section-title">è‡ªåŠ¨ç¯æ‰‡å½¢è½¬æ¢ç®—æ³•</div>
            <div class="controls">
                <div class="control-group">
                    <button id="run-algorithm" style="width: 100%; padding: 10px; cursor: pointer; background: #9C27B0; color: white; border: none; border-radius: 4px; font-size: 14px; margin-bottom: 10px;">
                        è¿è¡Œç®—æ³• (Run Algorithm)
                    </button>
                </div>
                <div class="control-group">
                    <button id="debug-sector" style="width: 100%; padding: 8px; cursor: pointer; background: #607D8B; color: white; border: none; border-radius: 4px; font-size: 12px;">
                        è°ƒè¯•æ‰‡ç¯ (Debug Sector)
                    </button>
                </div>
                <div id="algorithm-stats" style="margin-top: 10px; padding: 10px; background: #f3e5f5; border-radius: 4px; font-size: 12px; display: none;"></div>
            </div>

            <div class="info">
                <strong>è¯´æ˜ï¼š</strong><br>
                â€¢ 21Ã—21 æ ¼å­ï¼Œä¸­å¿ƒ (10.5, 10.5)<br>
                â€¢ ç¼–ç å†…å®¹ï¼š"HELLO QR"<br>
                â€¢ åœ†ç¯ï¼šä»åŠå¾„ 0.5 å¼€å§‹ï¼Œæ¯éš” 0.5 ä¸ªå•ä½ç”»ä¸€ä¸ªåœ†<br>
                â€¢ æ”¾å°„çº¿ï¼šä»ä¸­å¿ƒå‡ºå‘ï¼Œæ¯éš” 3Â° ç”»ä¸€æ¡çº¿ï¼Œå…± 120 æ¡<br>
                â€¢ ç”¨äºè°ƒè¯•å’Œå¯è§†åŒ–å¾„å‘/åˆ‡å‘å…³ç³»
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/qrcode-generator@1.4.4/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.min.js"></script>
    <script>
        // QR Code v1 parameters
        const moduleCount = 21;
        const cellSize = 40; // SVGå•ä½ (doubled for better visibility)
        const svgSize = moduleCount * cellSize;
        const center = { x: moduleCount / 2, y: moduleCount / 2 }; // (10.5, 10.5)

        // Create SVG (with 10% margin)
        const svgContainer = document.getElementById('svg-container');
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('width', svgSize);
        svg.setAttribute('height', svgSize);
        // Add 10% margin: viewBox expanded from 21 to ~23.3, centered
        const margin = moduleCount * 0.1;
        const initialViewBox = {
            x: -margin,
            y: -margin,
            width: moduleCount + 2 * margin,
            height: moduleCount + 2 * margin
        };
        svg.setAttribute('viewBox', `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
        svgContainer.appendChild(svg);

        // Zoom limits: 50% to 1000% (viewBox width: 50.4 to 2.52)
        const minViewBoxWidth = initialViewBox.width / 10;  // 1000% zoom
        const maxViewBoxWidth = initialViewBox.width * 2;   // 50% zoom

        // Generate real QR code using qrcode-generator library
        function generateQRPattern() {
            // Create QR code with type 1 (21x21), error correction level L
            const qr = qrcode(1, 'L');
            qr.addData('HELLO QR');
            qr.make();

            const count = qr.getModuleCount();
            const modules = Array(count).fill(null).map(() => Array(count).fill(false));

            for (let row = 0; row < count; row++) {
                for (let col = 0; col < count; col++) {
                    modules[row][col] = qr.isDark(row, col);
                }
            }

            return modules;
        }

        const qrModules = generateQRPattern();

        // Fine-grained cell state management (grid + radials + rings)
        const STORAGE_KEY_BASE = 'qr-circle-base';
        const STORAGE_KEY_CELLS = 'qr-circle-cells';
        let baseModuleState = {}; // { "row,col": true/false } - base QR pattern
        let cellState = {}; // { "grid:row,col|radial:idx|ring:idx": true/false } - fine-grained cells (manual edits)

        // Algorithm state (automatic conversion result)
        // Store sector colors directly, without grid subdivision
        let sectorColors = {}; // { "radial:idx|ring:idx": true/false } - sector-based colors
        let algorithmState = {}; // Legacy: for comparison with manual edits
        let algorithmStats = null; // Algorithm execution statistics

        // Undo/Redo history stacks
        let undoStack = []; // Stack of operations for undo
        let redoStack = []; // Stack of operations for redo
        const MAX_HISTORY = 100; // Maximum history size

        const RADIAL_COUNT = 120; // 120 radial lines (every 3Â°)
        const RING_INTERVAL = 0.5; // Ring every 0.5 units
        const maxRadius = Math.sqrt(2) * moduleCount / 2;
        const RING_COUNT = Math.ceil(maxRadius / RING_INTERVAL);

        // Calculate which cell a point belongs to
        function getCellAtPoint(x, y) {
            const gridRow = Math.floor(y);
            const gridCol = Math.floor(x);

            // Calculate radial index (angle)
            const dx = x - center.x;
            const dy = y - center.y;
            let angle = Math.atan2(dy, dx) * 180 / Math.PI; // -180 to 180
            if (angle < 0) angle += 360; // 0 to 360
            const radialIndex = Math.floor(angle / 3); // 0-119

            // Calculate ring index (radius)
            const radius = Math.sqrt(dx * dx + dy * dy);
            const ringIndex = Math.floor(radius / RING_INTERVAL);

            return {
                gridRow,
                gridCol,
                radialIndex,
                ringIndex,
                id: `grid:${gridRow},${gridCol}|radial:${radialIndex}|ring:${ringIndex}`
            };
        }

        // Get cell state (check cell state first, then fall back to base module)
        function getCellState(cellId, gridRow, gridCol) {
            if (cellState.hasOwnProperty(cellId)) {
                return cellState[cellId];
            }
            // Fall back to base module state
            return baseModuleState[`${gridRow},${gridCol}`] || false;
        }

        // Toggle cell state
        function toggleCell(cellInfo) {
            const currentState = getCellState(cellInfo.id, cellInfo.gridRow, cellInfo.gridCol);
            const newState = !currentState;

            // Record operation for undo (è®°å½•æ˜¯å¦åœ¨ cellState ä¸­å­˜åœ¨)
            undoStack.push({
                cellInfo: cellInfo,
                previousState: currentState,
                newState: newState,
                hadCellState: cellState.hasOwnProperty(cellInfo.id) // è®°å½•ä¹‹å‰æ˜¯å¦åœ¨ cellState ä¸­
            });

            // Limit history size
            if (undoStack.length > MAX_HISTORY) {
                undoStack.shift();
            }

            // Clear redo stack when new operation is performed
            redoStack = [];

            // Apply change
            cellState[cellInfo.id] = newState;
            saveCellState();
            drawCells();
            drawManualDisplay(); // Update manual sector display
        }

        // Undo last operation
        function undo() {
            if (undoStack.length === 0) return;

            const operation = undoStack.pop();
            redoStack.push(operation);

            // Restore previous state
            if (operation.hadCellState) {
                // ä¹‹å‰åœ¨ cellState ä¸­ï¼Œæ¢å¤åŸå€¼
                cellState[operation.cellInfo.id] = operation.previousState;
            } else {
                // ä¹‹å‰ä¸åœ¨ cellState ä¸­ï¼ˆä½¿ç”¨ base stateï¼‰ï¼Œåˆ é™¤
                delete cellState[operation.cellInfo.id];
            }

            console.log('[Undo] cellState after undo:', Object.keys(cellState).length, 'cells');

            saveCellState();
            drawCells();
            drawManualDisplay(); // Update manual sector display

            // å¼ºåˆ¶æµè§ˆå™¨é‡ç»˜
            svg.getBoundingClientRect();
        }

        // Redo last undone operation
        function redo() {
            if (redoStack.length === 0) return;

            const operation = redoStack.pop();
            undoStack.push(operation);

            // Reapply operation
            cellState[operation.cellInfo.id] = operation.newState;

            console.log('[Redo] cellState after redo:', Object.keys(cellState).length, 'cells');

            saveCellState();
            drawCells();
            drawManualDisplay(); // Update manual sector display

            // å¼ºåˆ¶æµè§ˆå™¨é‡ç»˜
            svg.getBoundingClientRect();
        }

        // Load/save functions
        function loadCellState() {
            // Load base pattern
            const savedBase = localStorage.getItem(STORAGE_KEY_BASE);
            if (savedBase) {
                try {
                    baseModuleState = JSON.parse(savedBase);
                } catch (e) {
                    initializeBaseState();
                }
            } else {
                initializeBaseState();
            }

            // Load cell modifications
            const savedCells = localStorage.getItem(STORAGE_KEY_CELLS);
            if (savedCells) {
                try {
                    cellState = JSON.parse(savedCells);
                } catch (e) {
                    cellState = {};
                }
            }
        }

        function initializeBaseState() {
            baseModuleState = {};
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    baseModuleState[`${row},${col}`] = qrModules[row][col];
                }
            }
            localStorage.setItem(STORAGE_KEY_BASE, JSON.stringify(baseModuleState));
        }

        function saveCellState() {
            localStorage.setItem(STORAGE_KEY_CELLS, JSON.stringify(cellState));
        }

        loadCellState();

        // Create global defs for clipPaths
        const globalDefs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
        globalDefs.setAttribute('id', 'global-defs');
        svg.appendChild(globalDefs);

        // Layer groups (bottom to top: modules, grid, circles, radials, cells)
        const moduleLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        moduleLayer.setAttribute('id', 'module-layer');
        svg.appendChild(moduleLayer);

        const gridLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        gridLayer.setAttribute('id', 'grid-layer');
        svg.appendChild(gridLayer);

        const circleLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        circleLayer.setAttribute('id', 'circle-layer');
        svg.appendChild(circleLayer);

        const radialLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        radialLayer.setAttribute('id', 'radial-layer');
        svg.appendChild(radialLayer);

        // Cell layer for fine-grained cells (on top of everything)
        const cellLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        cellLayer.setAttribute('id', 'cell-layer');
        svg.appendChild(cellLayer);

        // White ring layer (white circles overlay, on top of everything)
        const whiteRingLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        whiteRingLayer.setAttribute('id', 'white-ring-layer');
        svg.appendChild(whiteRingLayer);

        // Algorithm layer (automatic conversion result, highest z-index for comparison)
        const algorithmLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        algorithmLayer.setAttribute('id', 'algorithm-layer');
        algorithmLayer.setAttribute('opacity', '0.7'); // Semi-transparent for comparison
        svg.appendChild(algorithmLayer);

        // === NEW: Three independent display layers (no clipping, pure coordinate systems) ===
        // Original layer: rectangular coordinate system (red)
        const originalDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        originalDisplayLayer.setAttribute('id', 'original-display-layer');
        originalDisplayLayer.setAttribute('opacity', '0.6'); // Semi-transparent for color blending
        svg.appendChild(originalDisplayLayer);

        // Manual layer: annular coordinate system (blue)
        const manualDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        manualDisplayLayer.setAttribute('id', 'manual-display-layer');
        manualDisplayLayer.setAttribute('opacity', '0.6'); // Semi-transparent for color blending
        svg.appendChild(manualDisplayLayer);

        // Algorithm display layer: annular coordinate system (green)
        const algorithmDisplayLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        algorithmDisplayLayer.setAttribute('id', 'algorithm-display-layer');
        algorithmDisplayLayer.setAttribute('opacity', '0.6'); // Semi-transparent for color blending
        svg.appendChild(algorithmDisplayLayer);

        // Error detection layer: highlight insufficient coverage (highest z-index)
        const errorLayer = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        errorLayer.setAttribute('id', 'error-layer');
        svg.appendChild(errorLayer);

        // Draw grid
        function drawGrid() {
            gridLayer.innerHTML = '';

            // Vertical lines
            for (let i = 0; i <= moduleCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', i);
                line.setAttribute('y1', 0);
                line.setAttribute('x2', i);
                line.setAttribute('y2', moduleCount);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                gridLayer.appendChild(line);
            }

            // Horizontal lines
            for (let i = 0; i <= moduleCount; i++) {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', 0);
                line.setAttribute('y1', i);
                line.setAttribute('x2', moduleCount);
                line.setAttribute('y2', i);
                line.setAttribute('stroke', '#999');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                gridLayer.appendChild(line);
            }
        }

        // Draw circles (every 0.5 unit)
        function drawCircles() {
            circleLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2; // Diagonal distance

            for (let r = 0.5; r <= maxRadius; r += 0.5) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', center.x);
                circle.setAttribute('cy', center.y);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', '#ff6b6b');
                circle.setAttribute('stroke-width', '1');
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.setAttribute('opacity', '0.5');
                circleLayer.appendChild(circle);
            }
        }

        // Draw radial lines (every 3 degrees, 120 total)
        function drawRadialLines() {
            radialLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2;

            for (let degree = 0; degree < 360; degree += 3) { // Every 3 degrees
                const angle = degree * Math.PI / 180; // Convert to radians
                const x2 = center.x + maxRadius * Math.cos(angle);
                const y2 = center.y + maxRadius * Math.sin(angle);

                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', center.x);
                line.setAttribute('y1', center.y);
                line.setAttribute('x2', x2);
                line.setAttribute('y2', y2);
                line.setAttribute('stroke', '#4ecdc4');
                line.setAttribute('stroke-width', '1');
                line.setAttribute('vector-effect', 'non-scaling-stroke');
                line.setAttribute('opacity', '0.5');
                radialLayer.appendChild(line);
            }

            // Draw center point
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', center.x);
            centerDot.setAttribute('cy', center.y);
            centerDot.setAttribute('r', '0.1');
            centerDot.setAttribute('fill', '#4ecdc4');
            radialLayer.appendChild(centerDot);
        }

        // Draw white rings (overlay circles with white stroke)
        function drawWhiteRings() {
            whiteRingLayer.innerHTML = '';

            const maxRadius = Math.sqrt(2) * moduleCount / 2; // Diagonal distance

            for (let r = 0.5; r <= maxRadius; r += 0.5) {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', center.x);
                circle.setAttribute('cy', center.y);
                circle.setAttribute('r', r);
                circle.setAttribute('fill', 'none');
                circle.setAttribute('stroke', 'white');
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('vector-effect', 'non-scaling-stroke');
                circle.setAttribute('opacity', '0.8');
                whiteRingLayer.appendChild(circle);
            }
        }

        // ========== ALGORITHM: Automatic Sector-Ring Conversion ==========

        // Create a complete sector (annular segment) path - NO grid clipping
        function createCompleteSectorPath(radialIndex, ringIndex) {
            const angle1 = radialIndex * 3 * Math.PI / 180;
            const angle2 = (radialIndex + 1) * 3 * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Calculate four vertices
            const x1_inner = center.x + r1 * Math.cos(angle1);
            const y1_inner = center.y + r1 * Math.sin(angle1);
            const x2_inner = center.x + r1 * Math.cos(angle2);
            const y2_inner = center.y + r1 * Math.sin(angle2);
            const x1_outer = center.x + r2 * Math.cos(angle1);
            const y1_outer = center.y + r2 * Math.sin(angle1);
            const x2_outer = center.x + r2 * Math.cos(angle2);
            const y2_outer = center.y + r2 * Math.sin(angle2);

            // Determine if arc is large (> 180 degrees)
            const largeArc = (angle2 - angle1) > Math.PI ? 1 : 0;

            // Build annular sector path
            let pathData = `M ${x1_inner} ${y1_inner}`;  // Start at inner arc, angle1
            pathData += ` A ${r1} ${r1} 0 ${largeArc} 1 ${x2_inner} ${y2_inner}`;  // Inner arc to angle2
            pathData += ` L ${x2_outer} ${y2_outer}`;  // Line to outer arc
            pathData += ` A ${r2} ${r2} 0 ${largeArc} 0 ${x1_outer} ${y1_outer}`;  // Outer arc back to angle1
            pathData += ` Z`;  // Close path

            return pathData;
        }

        // Check if a point is inside an annular sector (ring segment)
        function isPointInSector(px, py, radialIndex, ringIndex) {
            const dx = px - center.x;
            const dy = py - center.y;
            const radius = Math.sqrt(dx * dx + dy * dy);

            // Check radius range
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            if (radius < r1 || radius > r2) return false;

            // Check angle range
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;
            const a1 = radialIndex * 3;
            const a2 = (radialIndex + 1) * 3;

            return angle >= a1 && angle < a2;
        }

        // Calculate overlap area between a sector and a grid cell using Monte Carlo sampling
        function calculateOverlapArea(gridRow, gridCol, radialIndex, ringIndex, samples = 100) {
            let hits = 0;

            // Sample points in the grid cell
            for (let i = 0; i < samples; i++) {
                for (let j = 0; j < samples; j++) {
                    const px = gridCol + (i + 0.5) / samples;
                    const py = gridRow + (j + 0.5) / samples;

                    if (isPointInSector(px, py, radialIndex, ringIndex)) {
                        hits++;
                    }
                }
            }

            const cellArea = 1.0; // Unit cell area
            return (hits / (samples * samples)) * cellArea;
        }

        // Find all sectors that overlap with a grid cell
        function findOverlappingSectors(gridRow, gridCol) {
            const overlaps = [];
            const maxRadius = Math.sqrt(2) * moduleCount / 2;
            const maxRing = Math.ceil(maxRadius / RING_INTERVAL);

            // Check cell center to determine which radials/rings might overlap
            const cellCenterX = gridCol + 0.5;
            const cellCenterY = gridRow + 0.5;
            const dx = cellCenterX - center.x;
            const dy = cellCenterY - center.y;
            const cellRadius = Math.sqrt(dx * dx + dy * dy);
            let cellAngle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (cellAngle < 0) cellAngle += 360;

            // Search nearby rings (Â±1 from cell center ring)
            const centerRing = Math.floor(cellRadius / RING_INTERVAL);
            for (let ring = Math.max(0, centerRing - 1); ring <= Math.min(maxRing, centerRing + 2); ring++) {
                // Search nearby radials (Â±2 from cell center radial)
                const centerRadial = Math.floor(cellAngle / 3);
                for (let radial = centerRadial - 2; radial <= centerRadial + 2; radial++) {
                    const normalizedRadial = ((radial % 120) + 120) % 120;

                    const overlapArea = calculateOverlapArea(gridRow, gridCol, normalizedRadial, ring, 50);
                    if (overlapArea > 0.001) { // Threshold to avoid floating point noise
                        const cellId = `grid:${gridRow},${gridCol}|radial:${normalizedRadial}|ring:${ring}`;
                        overlaps.push({
                            cellId,
                            radialIndex: normalizedRadial,
                            ringIndex: ring,
                            overlapArea
                        });
                    }
                }
            }

            return overlaps;
        }

        // Find all grid cells that overlap with a sector
        function findOverlappingGridCells(radialIndex, ringIndex) {
            const overlaps = [];

            // Determine bounding box of the sector
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const a1 = radialIndex * 3 * Math.PI / 180;
            const a2 = (radialIndex + 1) * 3 * Math.PI / 180;

            // Calculate sector bounding box
            const points = [
                { x: center.x + r1 * Math.cos(a1), y: center.y + r1 * Math.sin(a1) },
                { x: center.x + r1 * Math.cos(a2), y: center.y + r1 * Math.sin(a2) },
                { x: center.x + r2 * Math.cos(a1), y: center.y + r2 * Math.sin(a1) },
                { x: center.x + r2 * Math.cos(a2), y: center.y + r2 * Math.sin(a2) }
            ];

            const minRow = Math.floor(Math.min(...points.map(p => p.y))) - 1;
            const maxRow = Math.ceil(Math.max(...points.map(p => p.y))) + 1;
            const minCol = Math.floor(Math.min(...points.map(p => p.x))) - 1;
            const maxCol = Math.ceil(Math.max(...points.map(p => p.x))) + 1;

            // Check each grid cell in bounding box
            for (let row = minRow; row <= maxRow; row++) {
                for (let col = minCol; col <= maxCol; col++) {
                    const overlapArea = calculateOverlapArea(row, col, radialIndex, ringIndex, 50);
                    if (overlapArea > 0.001) {
                        overlaps.push({
                            gridRow: row,
                            gridCol: col,
                            overlapArea
                        });
                    }
                }
            }

            return overlaps;
        }

        // SIMPLIFIED ALGORITHM: Calculate sector color based on maximum overlap area
        function calculateSectorColor_Simplified(radialIndex, ringIndex, debug = false) {
            // Find all grid cells that overlap with this sector
            const overlappingGrids = findOverlappingGridCells(radialIndex, ringIndex);

            if (overlappingGrids.length === 0) {
                return false; // Default to white if no overlap
            }

            // Collect colors and areas
            const gridColors = new Set();
            const colorAreas = { black: 0, white: 0 };
            const gridDetails = [];

            for (const overlap of overlappingGrids) {
                const { gridRow, gridCol, overlapArea } = overlap;
                const isBlack = baseModuleState[`${gridRow},${gridCol}`] || false;

                gridColors.add(isBlack);

                if (isBlack) {
                    colorAreas.black += overlapArea;
                } else {
                    colorAreas.white += overlapArea;
                }

                if (debug) {
                    gridDetails.push({
                        grid: `${gridRow},${gridCol}`,
                        color: isBlack ? 'black' : 'white',
                        area: overlapArea.toFixed(4)
                    });
                }
            }

            // Case 1 & 2: All grids have the same color
            const result = gridColors.size === 1
                ? Array.from(gridColors)[0]
                : colorAreas.black > colorAreas.white;

            if (debug) {
                console.log(`[Sector ${radialIndex},${ringIndex}]`, {
                    overlappingGrids: gridDetails,
                    colorAreas: {
                        black: colorAreas.black.toFixed(4),
                        white: colorAreas.white.toFixed(4)
                    },
                    sameColor: gridColors.size === 1,
                    result: result ? 'BLACK' : 'WHITE'
                });
            }

            return result;
        }

        // Check if a grid cell violates the 25% constraint
        function checkGridConstraint(gridRow, gridCol) {
            const isGridBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
            const gridArea = 1.0;
            const maxChange = gridArea * 0.25;

            const overlappingSectors = findOverlappingSectors(gridRow, gridCol);

            let totalChange = 0;
            for (const sector of overlappingSectors) {
                const sectorColor = algorithmState[sector.cellId];
                if (sectorColor === undefined) continue;

                const overlapArea = sector.overlapArea;

                if (isGridBlack && !sectorColor) {
                    // Grid black, sector white -> subtraction
                    totalChange += overlapArea;
                } else if (!isGridBlack && sectorColor) {
                    // Grid white, sector black -> addition
                    totalChange += overlapArea;
                }
            }

            return {
                violated: totalChange > maxChange,
                totalChange,
                maxChange,
                percentage: (totalChange / gridArea) * 100
            };
        }

        // SIMPLIFIED ALGORITHM: Pure sector-based conversion using Monte Carlo
        async function runConversionAlgorithm() {
            console.log('[Algorithm] ğŸš€ Starting PURE SECTOR-BASED conversion...');
            const startTime = performance.now();

            sectorColors = {};
            algorithmState = {}; // Also populate for comparison
            let sameColorCount = 0;
            let differentColorCount = 0;

            const maxRadius = Math.sqrt(2) * moduleCount / 2;
            const maxRing = Math.ceil(maxRadius / RING_INTERVAL);
            const totalSectors = 120 * maxRing;

            console.log('[Algorithm] Processing sectors (radial Ã— ring)...');
            let processed = 0;

            // Iterate through all sectors (radial, ring) - NO grid subdivision
            for (let ring = 0; ring <= maxRing; ring++) {
                for (let radial = 0; radial < 120; radial++) {
                    // Calculate color for this complete sector
                    const color = calculateSectorColor_Simplified(radial, ring);
                    const sectorId = `radial:${radial}|ring:${ring}`;
                    sectorColors[sectorId] = color;

                    // Also populate algorithmState for comparison with manual edits
                    // (manual edits are grid-subdivided, so we need to map sectors to grids)
                    const overlappingGrids = findOverlappingGridCells(radial, ring);
                    for (const overlap of overlappingGrids) {
                        const cellId = `grid:${overlap.gridRow},${overlap.gridCol}|radial:${radial}|ring:${ring}`;
                        algorithmState[cellId] = color;
                    }

                    // Track statistics
                    const colors = new Set(overlappingGrids.map(g => baseModuleState[`${g.gridRow},${g.gridCol}`] || false));
                    if (colors.size === 1) {
                        sameColorCount++;
                    } else {
                        differentColorCount++;
                    }

                    processed++;
                    if (processed % 200 === 0) {
                        console.log(`[Algorithm] Processed ${processed}/${totalSectors} sectors`);
                    }
                }
            }

            const endTime = performance.now();
            const elapsed = ((endTime - startTime) / 1000).toFixed(2);

            algorithmStats = {
                totalSectors: Object.keys(sectorColors).length,
                sameColorSectors: sameColorCount,
                mixedColorSectors: differentColorCount,
                elapsedSeconds: elapsed
            };

            console.log('[Algorithm] âœ… Completed!', algorithmStats);
            console.log(`[Algorithm] Pure sectors: ${Object.keys(sectorColors).length}`);
            console.log(`[Algorithm] Grid-mapped cells: ${Object.keys(algorithmState).length}`);
            return algorithmStats;
        }

        // Compare algorithm result with manual edits
        function compareWithManualEdits() {
            console.log('[Compare] ğŸ“Š Comparing algorithm vs manual edits...');

            const manualCells = Object.keys(cellState);
            const algorithmCells = Object.keys(algorithmState);

            let totalCompared = 0;
            let matchCount = 0;
            let mismatchCount = 0;
            const mismatches = [];

            // Compare cells that exist in both
            for (const cellId of algorithmCells) {
                if (cellState.hasOwnProperty(cellId)) {
                    totalCompared++;
                    const manualColor = cellState[cellId];
                    const algoColor = algorithmState[cellId];

                    if (manualColor === algoColor) {
                        matchCount++;
                    } else {
                        mismatchCount++;
                        mismatches.push({
                            cellId,
                            manual: manualColor,
                            algorithm: algoColor
                        });
                    }
                }
            }

            const matchPercentage = totalCompared > 0 ? ((matchCount / totalCompared) * 100).toFixed(1) : 0;

            console.log(`[Compare] Total compared: ${totalCompared}`);
            console.log(`[Compare] Matches: ${matchCount} (${matchPercentage}%)`);
            console.log(`[Compare] Mismatches: ${mismatchCount}`);

            if (mismatches.length > 0 && mismatches.length <= 10) {
                console.log('[Compare] Sample mismatches:', mismatches);
            }

            return {
                totalCompared,
                matchCount,
                mismatchCount,
                matchPercentage,
                manualTotal: manualCells.length,
                algorithmTotal: algorithmCells.length
            };
        }

        // Fix a violated grid cell by flipping sectors with least impact
        function fixViolatedCell(gridRow, gridCol) {
            const isGridBlack = baseModuleState[`${gridRow},${gridCol}`] || false;
            const overlappingSectors = findOverlappingSectors(gridRow, gridCol);

            // Find sectors to flip
            const candidates = [];
            for (const sector of overlappingSectors) {
                const sectorColor = algorithmState[sector.cellId];
                if (sectorColor === undefined) continue;

                // If grid is black and sector is white (contributing to violation), consider flipping to black
                // If grid is white and sector is black (contributing to violation), consider flipping to white
                if ((isGridBlack && !sectorColor) || (!isGridBlack && sectorColor)) {
                    candidates.push({
                        cellId: sector.cellId,
                        overlapArea: sector.overlapArea
                    });
                }
            }

            // Flip the largest overlapping sector (most impact)
            if (candidates.length > 0) {
                candidates.sort((a, b) => b.overlapArea - a.overlapArea);
                const toFlip = candidates[0];
                algorithmState[toFlip.cellId] = !algorithmState[toFlip.cellId];
            }
        }

        // Draw algorithm result - PURE SECTOR SHAPES (no grid clipping)
        function drawAlgorithmResult() {
            algorithmLayer.innerHTML = '';

            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawAlgorithmResult] No sector colors to draw');
                return;
            }

            let drawnCount = 0;

            // Draw complete sectors (annular segments) - NO grid subdivision
            for (const [sectorId, color] of Object.entries(sectorColors)) {
                // Only draw black regions (skip white)
                if (!color) continue;

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path (no clipping)
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#00FF00'); // Green (ç®—æ³•ç»“æœ)
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                algorithmLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawAlgorithmResult] Drew', drawnCount, 'complete sectors (pure annular segments)');
        }

        // === NEW: Three independent display functions ===

        // Draw original QR code (rectangular coordinate system, red)
        function drawOriginalDisplay() {
            originalDisplayLayer.innerHTML = '';

            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    const isBlack = baseModuleState[`${row},${col}`];
                    if (!isBlack) continue; // Only draw black modules

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', col);
                    rect.setAttribute('y', row);
                    rect.setAttribute('width', 1);
                    rect.setAttribute('height', 1);
                    rect.setAttribute('fill', '#FF0000'); // Red
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('shape-rendering', 'crispEdges');

                    originalDisplayLayer.appendChild(rect);
                }
            }
        }

        // Draw manual sectors (annular coordinate system, blue)
        // Aggregate cellState by sector and draw complete sectors
        function drawManualDisplay() {
            manualDisplayLayer.innerHTML = '';

            // Aggregate cellState by sector (radial, ring)
            const sectorVotes = {}; // { "radial:idx|ring:idx": { black: count, white: count } }

            for (const [cellId, state] of Object.entries(cellState)) {
                // Parse cellId: "grid:row,col|radial:idx|ring:idx"
                const match = cellId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const sectorId = `radial:${match[1]}|ring:${match[2]}`;
                if (!sectorVotes[sectorId]) {
                    sectorVotes[sectorId] = { black: 0, white: 0 };
                }

                if (state) {
                    sectorVotes[sectorId].black++;
                } else {
                    sectorVotes[sectorId].white++;
                }
            }

            // Draw sectors based on majority vote
            let drawnCount = 0;
            for (const [sectorId, votes] of Object.entries(sectorVotes)) {
                const isBlack = votes.black > votes.white;
                if (!isBlack) continue; // Only draw black sectors

                // Parse sector ID
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#0000FF'); // Blue
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                manualDisplayLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawManualDisplay] Drew', drawnCount, 'manual sectors');
        }

        // Draw algorithm sectors (annular coordinate system, green)
        function drawAlgorithmDisplay() {
            algorithmDisplayLayer.innerHTML = '';

            if (Object.keys(sectorColors).length === 0) {
                console.log('[drawAlgorithmDisplay] No sector colors to draw');
                return;
            }

            let drawnCount = 0;

            for (const [sectorId, color] of Object.entries(sectorColors)) {
                if (!color) continue; // Only draw black regions

                // Parse sector ID: "radial:idx|ring:idx"
                const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const radialIndex = parseInt(match[1]);
                const ringIndex = parseInt(match[2]);

                // Create complete sector path
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('d', createCompleteSectorPath(radialIndex, ringIndex));
                path.setAttribute('fill', '#00FF00'); // Green
                path.setAttribute('stroke', 'none');
                path.setAttribute('shape-rendering', 'geometricPrecision');

                algorithmDisplayLayer.appendChild(path);
                drawnCount++;
            }

            console.log('[drawAlgorithmDisplay] Drew', drawnCount, 'algorithm sectors');
        }

        // === Coverage detection functions ===

        // Check if a point (x, y) is covered by a specific sector
        function isPointInSector(x, y, radialIndex, ringIndex) {
            const dx = x - center.x;
            const dy = y - center.y;
            const r = Math.sqrt(dx * dx + dy * dy);

            // Calculate angle in degrees [0, 360)
            let angle = Math.atan2(dy, dx) * 180 / Math.PI;
            if (angle < 0) angle += 360;

            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const angle1 = radialIndex * 3;
            const angle2 = (radialIndex + 1) * 3;

            return r >= r1 && r < r2 && angle >= angle1 && angle < angle2;
        }

        // Check if a point is covered by current display layers
        function isPointCovered(x, y, checkManual, checkAlgorithm) {
            if (checkManual && manualDisplayLayer.style.display !== 'none') {
                // Check manual sectors
                for (const [sectorId, votes] of Object.entries(getSectorVotesFromCellState())) {
                    const isBlack = votes.black > votes.white;
                    if (!isBlack) continue;

                    const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                    if (!match) continue;

                    const radialIndex = parseInt(match[1]);
                    const ringIndex = parseInt(match[2]);

                    if (isPointInSector(x, y, radialIndex, ringIndex)) {
                        return true;
                    }
                }
            }

            if (checkAlgorithm && algorithmDisplayLayer.style.display !== 'none') {
                // Check algorithm sectors
                for (const [sectorId, color] of Object.entries(sectorColors)) {
                    if (!color) continue; // Only black sectors

                    const match = sectorId.match(/radial:(\d+)\|ring:(\d+)/);
                    if (!match) continue;

                    const radialIndex = parseInt(match[1]);
                    const ringIndex = parseInt(match[2]);

                    if (isPointInSector(x, y, radialIndex, ringIndex)) {
                        return true;
                    }
                }
            }

            return false;
        }

        // Get sector votes from cellState (same logic as drawManualDisplay)
        function getSectorVotesFromCellState() {
            const sectorVotes = {};
            for (const [cellId, state] of Object.entries(cellState)) {
                const match = cellId.match(/radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const sectorId = `radial:${match[1]}|ring:${match[2]}`;
                if (!sectorVotes[sectorId]) {
                    sectorVotes[sectorId] = { black: 0, white: 0 };
                }

                if (state) {
                    sectorVotes[sectorId].black++;
                } else {
                    sectorVotes[sectorId].white++;
                }
            }
            return sectorVotes;
        }

        // Detect coverage errors for all black modules
        function detectCoverageErrors(checkManual = true, checkAlgorithm = true) {
            console.log('[detectCoverageErrors] Starting detection...');
            const errors = [];
            const sampleSize = 20; // 20Ã—20 sampling for each module

            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    const isBlack = baseModuleState[`${row},${col}`];
                    if (!isBlack) continue; // Only check black modules

                    let coveredCount = 0;
                    const totalCount = sampleSize * sampleSize;

                    // Sample points within the module rectangle [col, col+1] Ã— [row, row+1]
                    for (let i = 0; i < sampleSize; i++) {
                        for (let j = 0; j < sampleSize; j++) {
                            const x = col + (i + 0.5) / sampleSize;
                            const y = row + (j + 0.5) / sampleSize;

                            if (isPointCovered(x, y, checkManual, checkAlgorithm)) {
                                coveredCount++;
                            }
                        }
                    }

                    const coverage = coveredCount / totalCount;
                    if (coverage < 0.9) { // Coverage < 90% (error > 10%)
                        errors.push({ row, col, coverage });
                    }
                }
            }

            console.log(`[detectCoverageErrors] Found ${errors.length} errors`);
            return errors;
        }

        // Draw error markers on error layer
        function drawErrorMarkers(errors) {
            errorLayer.innerHTML = '';

            for (const error of errors) {
                const { row, col, coverage } = error;

                // Draw a thick red border around the module
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', col);
                rect.setAttribute('y', row);
                rect.setAttribute('width', 1);
                rect.setAttribute('height', 1);
                rect.setAttribute('fill', 'none');
                rect.setAttribute('stroke', '#FF0000'); // Red
                rect.setAttribute('stroke-width', '0.08');
                rect.setAttribute('opacity', '0.9');

                errorLayer.appendChild(rect);

                // Add text label showing coverage percentage
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', col + 0.5);
                text.setAttribute('y', row + 0.5);
                text.setAttribute('font-size', '0.25');
                text.setAttribute('fill', '#FF0000');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('dominant-baseline', 'middle');
                text.textContent = Math.round(coverage * 100) + '%';

                errorLayer.appendChild(text);
            }

            console.log(`[drawErrorMarkers] Drew ${errors.length} error markers`);
        }

        // Check if position is in Finder Pattern
        function isInFinderPattern(row, col) {
            // Top-left (0-6, 0-6)
            if (row < 7 && col < 7) return 'top-left';
            // Top-right (0-6, 14-20)
            if (row < 7 && col >= 14) return 'top-right';
            // Bottom-left (14-20, 0-6)
            if (row >= 14 && col < 7) return 'bottom-left';
            return null;
        }

        // Draw circular finder patterns
        function drawCircularFinderPattern(centerX, centerY) {
            const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
            const maskId = `finder-mask-${centerX}-${centerY}`;
            const mask = document.createElementNS('http://www.w3.org/2000/svg', 'mask');
            mask.setAttribute('id', maskId);

            // Outer circle (white)
            const outerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerCircle.setAttribute('cx', centerX);
            outerCircle.setAttribute('cy', centerY);
            outerCircle.setAttribute('r', 3.5);
            outerCircle.setAttribute('fill', 'white');
            mask.appendChild(outerCircle);

            // Middle circle (black - creates white ring)
            const middleCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            middleCircle.setAttribute('cx', centerX);
            middleCircle.setAttribute('cy', centerY);
            middleCircle.setAttribute('r', 2.5);
            middleCircle.setAttribute('fill', 'black');
            mask.appendChild(middleCircle);

            // Inner circle (white)
            const innerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            innerCircle.setAttribute('cx', centerX);
            innerCircle.setAttribute('cy', centerY);
            innerCircle.setAttribute('r', 1.5);
            innerCircle.setAttribute('fill', 'white');
            mask.appendChild(innerCircle);

            defs.appendChild(mask);
            moduleLayer.appendChild(defs);

            // Draw the outer ring (use yellow for visibility)
            const outerRing = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            outerRing.setAttribute('cx', centerX);
            outerRing.setAttribute('cy', centerY);
            outerRing.setAttribute('r', 3.5);
            outerRing.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            outerRing.setAttribute('mask', `url(#${maskId})`);
            moduleLayer.appendChild(outerRing);

            // Draw the center dot (use yellow for visibility)
            const centerDot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerDot.setAttribute('cx', centerX);
            centerDot.setAttribute('cy', centerY);
            centerDot.setAttribute('r', 1.5);
            centerDot.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
            moduleLayer.appendChild(centerDot);
        }

        // Draw QR modules
        function drawModules() {
            moduleLayer.innerHTML = '';

            // Track which modules are in finder patterns (to skip them)
            const finderPatternModules = new Set();

            // Draw circular finder patterns
            const finderCenters = [
                { x: 3.5, y: 3.5 },      // Top-left
                { x: 17.5, y: 3.5 },     // Top-right
                { x: 3.5, y: 17.5 }      // Bottom-left
            ];

            // Define finder pattern regions (7x7 squares + 1-cell separator)
            const finderRegions = [
                { rowMin: 0, rowMax: 7, colMin: 0, colMax: 7 },      // Top-left (0-6) + separator
                { rowMin: 0, rowMax: 7, colMin: 14, colMax: 21 },    // Top-right (14-20) + separator
                { rowMin: 14, rowMax: 21, colMin: 0, colMax: 7 }     // Bottom-left (14-20) + separator
            ];

            // Draw circular finder patterns
            for (let i = 0; i < finderCenters.length; i++) {
                const center = finderCenters[i];
                const region = finderRegions[i];

                drawCircularFinderPattern(center.x, center.y);

                // Mark modules in this finder pattern region (including separator)
                for (let row = region.rowMin; row < region.rowMax; row++) {
                    for (let col = region.colMin; col < region.colMax; col++) {
                        finderPatternModules.add(`${row},${col}`);
                    }
                }
            }

            // Draw regular modules (excluding finder patterns) - base state only
            for (let row = 0; row < moduleCount; row++) {
                for (let col = 0; col < moduleCount; col++) {
                    if (finderPatternModules.has(`${row},${col}`)) continue;

                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', col);
                    rect.setAttribute('y', row);
                    rect.setAttribute('width', 1);
                    rect.setAttribute('height', 1);
                    rect.setAttribute('stroke', 'none');
                    rect.setAttribute('shape-rendering', 'crispEdges');

                    // Fill based on base module state (use red for visibility)
                    if (baseModuleState[`${row},${col}`]) {
                        rect.setAttribute('fill', '#FF0000'); // Red (åŸå§‹QR)
                    } else {
                        rect.setAttribute('fill', 'white');
                    }

                    moduleLayer.appendChild(rect);
                }
            }
        }

        // Draw fine-grained cells (modified cells overlay)
        function drawCells() {
            console.log('[drawCells] Redrawing', Object.keys(cellState).length, 'cells');

            // Clear cell layer and global defs
            cellLayer.innerHTML = '';
            globalDefs.innerHTML = '';

            let drawnCount = 0;
            // Draw each modified cell
            for (const [cellId, state] of Object.entries(cellState)) {
                // Parse cell ID: "grid:row,col|radial:idx|ring:idx"
                const match = cellId.match(/grid:(\d+),(\d+)\|radial:(\d+)\|ring:(\d+)/);
                if (!match) continue;

                const gridRow = parseInt(match[1]);
                const gridCol = parseInt(match[2]);
                const radialIndex = parseInt(match[3]);
                const ringIndex = parseInt(match[4]);

                // Create cell with clipPath
                const result = createCellWithClip(gridRow, gridCol, radialIndex, ringIndex, cellId);
                if (!result) continue;

                // Add clipPath to global defs
                globalDefs.appendChild(result.clipPath);

                // Set fill and style (use blue for manual edits)
                const fillColor = state ? '#0000FF' : 'white'; // Blue for black, white for white
                result.path.setAttribute('fill', fillColor);
                result.path.setAttribute('stroke', 'none');
                result.path.setAttribute('shape-rendering', 'crispEdges');

                cellLayer.appendChild(result.path);
                drawnCount++;
            }
            console.log('[drawCells] Actually drew', drawnCount, 'cells');
            console.log('[drawCells] Global defs now has', globalDefs.children.length, 'clipPaths');
        }

        // Create cell using clipPath for precise intersection
        function createCellWithClip(gridRow, gridCol, radialIndex, ringIndex, cellId) {
            const angle1 = radialIndex * 3 * Math.PI / 180;
            const angle2 = (radialIndex + 1) * 3 * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;

            // Create annular sector (ring sector) path
            const x1_inner = center.x + r1 * Math.cos(angle1);
            const y1_inner = center.y + r1 * Math.sin(angle1);
            const x2_inner = center.x + r1 * Math.cos(angle2);
            const y2_inner = center.y + r1 * Math.sin(angle2);
            const x1_outer = center.x + r2 * Math.cos(angle1);
            const y1_outer = center.y + r2 * Math.sin(angle1);
            const x2_outer = center.x + r2 * Math.cos(angle2);
            const y2_outer = center.y + r2 * Math.sin(angle2);

            // Determine if arc is large (> 180 degrees)
            const largeArc = (angle2 - angle1) > Math.PI ? 1 : 0;

            // Build sector path
            let sectorPath = `M ${x1_inner} ${y1_inner}`;  // Start at inner arc, angle1
            sectorPath += ` A ${r1} ${r1} 0 ${largeArc} 1 ${x2_inner} ${y2_inner}`;  // Inner arc to angle2
            sectorPath += ` L ${x2_outer} ${y2_outer}`;  // Line to outer arc
            sectorPath += ` A ${r2} ${r2} 0 ${largeArc} 0 ${x1_outer} ${y1_outer}`;  // Outer arc back to angle1
            sectorPath += ` Z`;  // Close path

            // Create clipPath with grid rectangle
            const clipPathId = `clip-${cellId.replace(/:/g, '-').replace(/,/g, '_')}`;
            const clipPath = document.createElementNS('http://www.w3.org/2000/svg', 'clipPath');
            clipPath.setAttribute('id', clipPathId);

            const clipRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            clipRect.setAttribute('x', gridCol);
            clipRect.setAttribute('y', gridRow);
            clipRect.setAttribute('width', 1);
            clipRect.setAttribute('height', 1);
            clipPath.appendChild(clipRect);

            // Create path with clipPath applied
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', sectorPath);
            path.setAttribute('clip-path', `url(#${clipPathId})`);

            return { path, clipPath };
        }

        // Old function (keep for reference, can be removed later)
        function createCellPath_OLD(gridRow, gridCol, radialIndex, ringIndex) {
            const angle1 = radialIndex * 4 * Math.PI / 180;
            const angle2 = (radialIndex + 1) * 4 * Math.PI / 180;
            const r1 = ringIndex * RING_INTERVAL;
            const r2 = (ringIndex + 1) * RING_INTERVAL;
            const gridLeft = gridCol;
            const gridRight = gridCol + 1;
            const gridTop = gridRow;
            const gridBottom = gridRow + 1;

            // Helper: check if point is in grid bounds
            const inGrid = (x, y) => x >= gridLeft && x <= gridRight && y >= gridTop && y <= gridBottom;

            // Helper: clip line segment to grid rectangle
            const clipLineToGrid = (x1, y1, x2, y2) => {
                // Liang-Barsky algorithm for line-rectangle clipping
                let t0 = 0, t1 = 1;
                const dx = x2 - x1;
                const dy = y2 - y1;

                const clipTest = (p, q) => {
                    if (p === 0) return q >= 0;
                    const r = q / p;
                    if (p < 0) {
                        if (r > t1) return false;
                        if (r > t0) t0 = r;
                    } else {
                        if (r < t0) return false;
                        if (r < t1) t1 = r;
                    }
                    return true;
                };

                if (clipTest(-dx, x1 - gridLeft) &&
                    clipTest(dx, gridRight - x1) &&
                    clipTest(-dy, y1 - gridTop) &&
                    clipTest(dy, gridBottom - y1)) {
                    return {
                        x1: x1 + t0 * dx,
                        y1: y1 + t0 * dy,
                        x2: x1 + t1 * dx,
                        y2: y1 + t1 * dy
                    };
                }
                return null;
            };

            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            let pathData = '';
            const vertices = [];

            // Calculate radial line segments clipped to grid
            for (let angle of [angle1, angle2]) {
                const maxR = Math.sqrt(2) * moduleCount;
                const x1 = center.x + r1 * Math.cos(angle);
                const y1 = center.y + r1 * Math.sin(angle);
                const x2 = center.x + r2 * Math.cos(angle);
                const y2 = center.y + r2 * Math.sin(angle);

                const clipped = clipLineToGrid(x1, y1, x2, y2);
                if (clipped) {
                    vertices.push({x: clipped.x1, y: clipped.y1, angle, r: r1, type: 'radial'});
                    vertices.push({x: clipped.x2, y: clipped.y2, angle, r: r2, type: 'radial'});
                }
            }

            // Add arc endpoints if they're in grid
            for (let angle of [angle1, angle2]) {
                for (let r of [r1, r2]) {
                    const x = center.x + r * Math.cos(angle);
                    const y = center.y + r * Math.sin(angle);
                    if (inGrid(x, y)) {
                        // Already added by radial lines
                    }
                }
            }

            // Sort vertices by angle
            vertices.sort((a, b) => {
                const angleA = Math.atan2(a.y - center.y, a.x - center.x);
                const angleB = Math.atan2(b.y - center.y, b.x - center.x);
                if (Math.abs(angleA - angleB) < 0.001) {
                    return a.r - b.r; // Same angle, sort by radius
                }
                return angleA - angleB;
            });

            if (vertices.length < 2) return null;

            // Build path with arcs
            pathData = `M ${vertices[0].x} ${vertices[0].y}`;

            for (let i = 0; i < vertices.length; i++) {
                const curr = vertices[i];
                const next = vertices[(i + 1) % vertices.length];

                const currAngle = Math.atan2(curr.y - center.y, curr.x - center.x);
                const nextAngle = Math.atan2(next.y - center.y, next.x - center.x);
                const currR = Math.sqrt(Math.pow(curr.x - center.x, 2) + Math.pow(curr.y - center.y, 2));
                const nextR = Math.sqrt(Math.pow(next.x - center.x, 2) + Math.pow(next.y - center.y, 2));

                // Check if same radius (arc) or same angle (radial line)
                if (Math.abs(currR - nextR) < 0.01) {
                    // Arc segment
                    const largeArc = Math.abs(nextAngle - currAngle) > Math.PI ? 1 : 0;
                    pathData += ` A ${currR} ${currR} 0 ${largeArc} 1 ${next.x} ${next.y}`;
                } else {
                    // Line segment
                    pathData += ` L ${next.x} ${next.y}`;
                }
            }

            pathData += ' Z';
            path.setAttribute('d', pathData);
            return path;
        }

        // Initial draw
        drawGrid();
        drawCircles();
        drawRadialLines();
        drawWhiteRings();
        drawModules();
        drawCells();

        // Draw new independent display layers
        drawOriginalDisplay();
        drawManualDisplay();
        // drawAlgorithmDisplay() will be called after algorithm runs

        // é»˜è®¤éšè—ç™½è‰²ç¯çº¿å±‚å’Œç®—æ³•å±‚
        whiteRingLayer.style.display = 'none';
        algorithmLayer.style.display = 'none';

        // éšè—æ—§çš„å›¾å±‚ï¼ˆç°åœ¨ä½¿ç”¨æ–°çš„ç‹¬ç«‹æ˜¾ç¤ºå›¾å±‚ï¼‰
        moduleLayer.style.display = 'none';
        cellLayer.style.display = 'none';

        // é»˜è®¤éšè—ç®—æ³•æ˜¾ç¤ºå±‚å’Œé”™è¯¯æ£€æµ‹å±‚
        algorithmDisplayLayer.style.display = 'none';
        errorLayer.style.display = 'none';

        // Toggle controls
        document.getElementById('show-grid').addEventListener('change', (e) => {
            gridLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-circles').addEventListener('change', (e) => {
            circleLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-radials').addEventListener('change', (e) => {
            radialLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        // show-modules removed - now using show-original for originalDisplayLayer

        document.getElementById('show-white-rings').addEventListener('change', (e) => {
            whiteRingLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        // Layer controls (ä¸‰åŸè‰²å›¾å±‚æ§åˆ¶ - æ§åˆ¶æ–°çš„ç‹¬ç«‹æ˜¾ç¤ºå›¾å±‚)
        document.getElementById('show-original').addEventListener('change', (e) => {
            originalDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-manual').addEventListener('change', (e) => {
            manualDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('show-algorithm').addEventListener('change', (e) => {
            algorithmDisplayLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        // Coverage detection controls
        document.getElementById('show-errors').addEventListener('change', (e) => {
            errorLayer.style.display = e.target.checked ? 'block' : 'none';
        });

        document.getElementById('run-detection').addEventListener('click', () => {
            const button = document.getElementById('run-detection');
            const statsDiv = document.getElementById('detection-stats');
            const checkbox = document.getElementById('show-errors');

            button.disabled = true;
            button.textContent = 'æ£€æµ‹ä¸­... (Detecting...)';
            statsDiv.style.display = 'none';

            // Check which layers are currently displayed
            const checkManual = manualDisplayLayer.style.display !== 'none';
            const checkAlgorithm = algorithmDisplayLayer.style.display !== 'none';

            if (!checkManual && !checkAlgorithm) {
                alert('è¯·å…ˆå‹¾é€‰è‡³å°‘ä¸€ä¸ªæ‰‡ç¯å›¾å±‚ï¼ˆäººå·¥æˆ–ç®—æ³•ï¼‰ï¼');
                button.disabled = false;
                button.textContent = 'æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)';
                return;
            }

            // Run detection in next frame to allow UI update
            setTimeout(() => {
                try {
                    const errors = detectCoverageErrors(checkManual, checkAlgorithm);
                    drawErrorMarkers(errors);

                    // Show stats
                    const totalBlackModules = Object.values(baseModuleState).filter(v => v).length;
                    const errorRate = ((errors.length / totalBlackModules) * 100).toFixed(1);

                    let statsHTML = `
                        <strong>æ£€æµ‹ç»“æœï¼š</strong><br>
                        â€¢ æ€»é»‘è‰²ç ç‚¹ï¼š${totalBlackModules}<br>
                        â€¢ è¦†ç›–ä¸è¶³ï¼ˆ<90%ï¼‰ï¼š${errors.length}<br>
                        â€¢ é”™è¯¯ç‡ï¼š${errorRate}%<br>
                        <br>
                        <strong>æ£€æµ‹èŒƒå›´ï¼š</strong><br>
                        ${checkManual ? 'âœ“ äººå·¥æ‰‡ç¯å±‚<br>' : ''}
                        ${checkAlgorithm ? 'âœ“ ç®—æ³•æ‰‡ç¯å±‚<br>' : ''}
                    `;

                    statsDiv.innerHTML = statsHTML;
                    statsDiv.style.display = 'block';

                    // Auto enable error display
                    if (errors.length > 0) {
                        checkbox.checked = true;
                        errorLayer.style.display = 'block';
                    }

                    alert(`æ£€æµ‹å®Œæˆï¼\nå‘ç° ${errors.length} ä¸ªè¦†ç›–ä¸è¶³çš„ç ç‚¹ï¼ˆ<90%ï¼‰\né”™è¯¯ç‡ï¼š${errorRate}%`);
                } catch (error) {
                    console.error('[Detection] Error:', error);
                    alert('æ£€æµ‹å¤±è´¥ï¼š' + error.message);
                } finally {
                    button.disabled = false;
                    button.textContent = 'æ£€æµ‹è¦†ç›–ç‡ (Detect Coverage)';
                }
            }, 10);
        });

        // Algorithm controls
        document.getElementById('run-algorithm').addEventListener('click', async () => {
            const button = document.getElementById('run-algorithm');
            const statsDiv = document.getElementById('algorithm-stats');
            const checkbox = document.getElementById('show-algorithm');

            button.disabled = true;
            button.textContent = 'è¿è¡Œä¸­... (Running...)';
            statsDiv.style.display = 'none';

            try {
                const stats = await runConversionAlgorithm();
                drawAlgorithmResult();
                drawAlgorithmDisplay(); // Draw on new independent display layer

                // Compare with manual edits if available
                let compareStats = null;
                if (Object.keys(cellState).length > 0) {
                    compareStats = compareWithManualEdits();
                }

                // Show stats
                let statsHTML = `
                    <strong>ç®—æ³•ç»Ÿè®¡ï¼ˆçº¯æ‰‡ç¯ï¼‰ï¼š</strong><br>
                    â€¢ æ€»æ‰‡ç¯æ•°ï¼š${stats.totalSectors}<br>
                    â€¢ å•è‰²æ‰‡ç¯ï¼š${stats.sameColorSectors}<br>
                    â€¢ æ··è‰²æ‰‡ç¯ï¼š${stats.mixedColorSectors}<br>
                    â€¢ è€—æ—¶ï¼š${stats.elapsedSeconds} ç§’<br>
                `;

                if (compareStats) {
                    statsHTML += `
                        <br>
                        <strong>ğŸ“Š å¯¹æ¯”äººå·¥æ ‡è®°ï¼š</strong><br>
                        â€¢ äººå·¥æ ‡è®°å•å…ƒï¼š${compareStats.manualTotal}<br>
                        â€¢ å¯¹æ¯”å•å…ƒæ•°ï¼š${compareStats.totalCompared}<br>
                        â€¢ åŒ¹é…ï¼š${compareStats.matchCount} (${compareStats.matchPercentage}%)<br>
                        â€¢ ä¸åŒ¹é…ï¼š${compareStats.mismatchCount}<br>
                    `;
                }

                statsHTML += `
                    <br>
                    <strong>é¢œè‰²è¯´æ˜ï¼ˆä¸‰åŸè‰²ï¼‰ï¼š</strong><br>
                    â€¢ ğŸ”´ çº¢è‰²ï¼šåŸå§‹æ–¹å½¢ç ç‚¹<br>
                    â€¢ ğŸ”µ è“è‰²ï¼šäººå·¥æ‰‡ç¯å›¾åƒ<br>
                    â€¢ ğŸŸ¢ ç»¿è‰²ï¼šç®—æ³•æ‰‡ç¯å›¾åƒ<br>
                    â€¢ âšª ç™½è‰²ï¼šç•™ç©ºï¼ˆä¸æ˜¾ç¤ºï¼‰
                `;

                statsDiv.innerHTML = statsHTML;
                statsDiv.style.display = 'block';

                // Auto enable display
                checkbox.checked = true;
                algorithmDisplayLayer.style.display = 'block';

                alert('ç®—æ³•æ‰§è¡Œå®Œæˆï¼\nè¯·ä½¿ç”¨"å›¾å±‚æ§åˆ¶"å¤é€‰æ¡†è‡ªç”±ç»„åˆæŸ¥çœ‹å¯¹æ¯”ï¼š\nğŸ”´ çº¢è‰² - åŸå§‹æ–¹å½¢ç ç‚¹\nğŸ”µ è“è‰² - äººå·¥æ‰‡ç¯å›¾åƒ\nğŸŸ¢ ç»¿è‰² - ç®—æ³•æ‰‡ç¯å›¾åƒ');
            } catch (error) {
                console.error('[Algorithm] Error:', error);
                alert('ç®—æ³•æ‰§è¡Œå¤±è´¥ï¼š' + error.message);
            } finally {
                button.disabled = false;
                button.textContent = 'è¿è¡Œç®—æ³• (Run Algorithm)';
            }
        });

        // Debug sector button
        document.getElementById('debug-sector').addEventListener('click', () => {
            const radial = parseInt(prompt('è¾“å…¥ radial index (0-119):', '30'));
            const ring = parseInt(prompt('è¾“å…¥ ring index (0-30):', '5'));

            if (isNaN(radial) || isNaN(ring)) {
                alert('æ— æ•ˆçš„è¾“å…¥');
                return;
            }

            console.log('========================================');
            console.log(`ğŸ” è°ƒè¯•æ‰‡ç¯: radial=${radial}, ring=${ring}`);
            console.log('========================================');

            // Call with debug flag
            const color = calculateSectorColor_Simplified(radial, ring, true);

            // Find manual edits for this sector
            const manualEdits = [];
            for (const [cellId, state] of Object.entries(cellState)) {
                if (cellId.includes(`radial:${radial}|ring:${ring}`)) {
                    manualEdits.push({ cellId, state });
                }
            }

            console.log('ğŸ“ äººå·¥æ ‡è®°:', manualEdits.length > 0 ? manualEdits : 'æ— ');

            // Check algorithm result
            const algoEdits = [];
            for (const [cellId, state] of Object.entries(algorithmState)) {
                if (cellId.includes(`radial:${radial}|ring:${ring}`)) {
                    algoEdits.push({ cellId, state });
                }
            }

            console.log('ğŸ¤– ç®—æ³•ç»“æœ:', algoEdits.length > 0 ? algoEdits : 'æ— ');
            console.log('========================================');

            alert(`è°ƒè¯•å®Œæˆï¼\nè¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºã€‚\n\næ‰‡ç¯é¢œè‰²: ${color ? 'é»‘è‰²' : 'ç™½è‰²'}\näººå·¥æ ‡è®°: ${manualEdits.length} ä¸ª\nç®—æ³•ç»“æœ: ${algoEdits.length} ä¸ª`);
        });

        // Mouse wheel zoom (zoom centered on cursor, limited to 50%-200%)
        svg.addEventListener('wheel', (e) => {
            e.preventDefault();

            // Get mouse position in SVG coordinates
            const point = svg.createSVGPoint();
            point.x = e.clientX;
            point.y = e.clientY;
            const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());

            // Calculate zoom factor
            const zoomFactor = e.deltaY > 0 ? 1.1 : 0.9;

            // Get current viewBox
            const viewBox = svg.viewBox.baseVal;

            // Calculate new dimensions
            let newWidth = viewBox.width * zoomFactor;
            let newHeight = viewBox.height * zoomFactor;

            // Apply zoom limits
            if (newWidth < minViewBoxWidth) {
                newWidth = minViewBoxWidth;
                newHeight = minViewBoxWidth; // Keep aspect ratio
            }
            if (newWidth > maxViewBoxWidth) {
                newWidth = maxViewBoxWidth;
                newHeight = maxViewBoxWidth;
            }

            // Adjust viewBox position to keep mouse position fixed
            const dx = (newWidth - viewBox.width) * (svgPoint.x - viewBox.x) / viewBox.width;
            const dy = (newHeight - viewBox.height) * (svgPoint.y - viewBox.y) / viewBox.height;

            svg.setAttribute('viewBox', `${viewBox.x - dx} ${viewBox.y - dy} ${newWidth} ${newHeight}`);
        });

        // Reset view button
        document.getElementById('reset-view').addEventListener('click', () => {
            svg.setAttribute('viewBox', `${initialViewBox.x} ${initialViewBox.y} ${initialViewBox.width} ${initialViewBox.height}`);
        });

        // Clear all modifications button
        document.getElementById('clear-modifications').addEventListener('click', () => {
            if (confirm('ç¡®å®šè¦æ¸…é™¤æ‰€æœ‰ä¿®æ”¹å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ã€‚')) {
                // Clear localStorage
                localStorage.removeItem(STORAGE_KEY_BASE);
                localStorage.removeItem(STORAGE_KEY_CELLS);

                // Reinitialize state
                cellState = {};
                initializeBaseState();

                // Redraw
                drawModules();
                drawCells();
                drawOriginalDisplay();
                drawManualDisplay();
            }
        });

        // Export settings
        document.getElementById('export-settings').addEventListener('click', () => {
            const settings = {
                version: '1.0',
                timestamp: new Date().toISOString(),
                qrText: 'HELLO QR',
                baseModuleState: baseModuleState,
                cellState: cellState
            };

            const json = JSON.stringify(settings, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `qr-circle-settings-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            console.log('[Export] è®¾ç½®å·²å¯¼å‡º');
        });

        // Import settings
        document.getElementById('import-settings').addEventListener('click', () => {
            document.getElementById('import-file').click();
        });

        document.getElementById('import-file').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const settings = JSON.parse(event.target.result);

                    if (!settings.version) {
                        alert('æ— æ•ˆçš„è®¾ç½®æ–‡ä»¶æ ¼å¼');
                        return;
                    }

                    // Import base module state
                    if (settings.baseModuleState) {
                        baseModuleState = settings.baseModuleState;
                        localStorage.setItem(STORAGE_KEY_BASE, JSON.stringify(baseModuleState));
                    }

                    // Import cell state
                    if (settings.cellState) {
                        cellState = settings.cellState;
                        localStorage.setItem(STORAGE_KEY_CELLS, JSON.stringify(cellState));
                    }

                    // Clear undo/redo stacks
                    undoStack = [];
                    redoStack = [];

                    // Redraw
                    drawModules();
                    drawCells();
                    drawOriginalDisplay();
                    drawManualDisplay();

                    console.log('[Import] è®¾ç½®å·²å¯¼å…¥:', settings);
                    alert('è®¾ç½®å¯¼å…¥æˆåŠŸï¼');
                } catch (error) {
                    console.error('[Import] å¯¼å…¥å¤±è´¥:', error);
                    alert('å¯¼å…¥å¤±è´¥ï¼šæ–‡ä»¶æ ¼å¼é”™è¯¯');
                }
            };
            reader.readAsText(file);

            // Reset file input
            e.target.value = '';
        });

        // QR recognition test button
        document.getElementById('test-qr').addEventListener('click', async () => {
            const button = document.getElementById('test-qr');
            const statusLight = document.getElementById('qr-status-light');
            const statusText = document.getElementById('qr-status-text');
            const resultDiv = document.getElementById('qr-result');

            // Disable button during test
            button.disabled = true;
            button.textContent = 'æµ‹è¯•ä¸­...';
            statusLight.style.background = '#FFA500'; // Orange
            statusText.textContent = 'è¯†åˆ«ä¸­...';
            statusText.style.color = '#FFA500';
            resultDiv.style.display = 'none';

            try {
                console.log('[Test QR] Starting test, cellState has', Object.keys(cellState).length, 'cells');
                console.log('[Test QR] cellLayer children:', cellLayer.children.length);

                // Temporarily hide auxiliary layers
                const gridDisplay = gridLayer.style.display;
                const circleDisplay = circleLayer.style.display;
                const radialDisplay = radialLayer.style.display;

                gridLayer.style.display = 'none';
                circleLayer.style.display = 'none';
                radialLayer.style.display = 'none';

                // Wait for repaint (increased to ensure SVG is fully rendered)
                await new Promise(resolve => setTimeout(resolve, 200));

                // Convert SVG to canvas
                const canvas = document.createElement('canvas');
                const scale = 4; // Higher resolution for better recognition
                canvas.width = moduleCount * scale;
                canvas.height = moduleCount * scale;
                const ctx = canvas.getContext('2d');

                // Create a temporary image from SVG
                const svgData = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);

                const img = new Image();
                await new Promise((resolve, reject) => {
                    img.onload = resolve;
                    img.onerror = reject;
                    img.src = url;
                });

                // Draw to canvas with white background
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                URL.revokeObjectURL(url);

                // Restore auxiliary layers
                gridLayer.style.display = gridDisplay;
                circleLayer.style.display = circleDisplay;
                radialLayer.style.display = radialDisplay;

                // Get image data
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

                // Recognize QR code using jsQR
                const code = jsQR(imageData.data, imageData.width, imageData.height, {
                    inversionAttempts: 'dontInvert'
                });

                if (code) {
                    // Success - green light
                    statusLight.style.background = '#4CAF50';
                    statusLight.style.boxShadow = '0 0 10px #4CAF50, inset 0 0 5px rgba(0,0,0,0.3)';
                    statusText.textContent = 'è¯†åˆ«æˆåŠŸ âœ“';
                    statusText.style.color = '#4CAF50';

                    resultDiv.innerHTML = `<strong>è¯†åˆ«å†…å®¹:</strong><br>${code.data}`;
                    resultDiv.style.display = 'block';
                    resultDiv.style.background = '#e8f5e9';
                    resultDiv.style.borderLeft = '4px solid #4CAF50';
                } else {
                    // Failed - red light
                    statusLight.style.background = '#f44336';
                    statusLight.style.boxShadow = '0 0 10px #f44336, inset 0 0 5px rgba(0,0,0,0.3)';
                    statusText.textContent = 'è¯†åˆ«å¤±è´¥ âœ—';
                    statusText.style.color = '#f44336';

                    resultDiv.innerHTML = '<strong>é”™è¯¯:</strong><br>æ— æ³•è¯†åˆ« QR ç ï¼Œå¯èƒ½æŸåæˆ–ä¿®æ”¹è¿‡å¤š';
                    resultDiv.style.display = 'block';
                    resultDiv.style.background = '#ffebee';
                    resultDiv.style.borderLeft = '4px solid #f44336';
                }
            } catch (error) {
                // Error - red light
                statusLight.style.background = '#f44336';
                statusLight.style.boxShadow = '0 0 10px #f44336, inset 0 0 5px rgba(0,0,0,0.3)';
                statusText.textContent = 'æµ‹è¯•å¤±è´¥';
                statusText.style.color = '#f44336';

                resultDiv.innerHTML = `<strong>é”™è¯¯:</strong><br>${error.message}`;
                resultDiv.style.display = 'block';
                resultDiv.style.background = '#ffebee';
                resultDiv.style.borderLeft = '4px solid #f44336';
            } finally {
                // Re-enable button
                button.disabled = false;
                button.textContent = 'æµ‹è¯•è¯†åˆ« (Test QR)';
            }
        });

        // Pan (drag) functionality + click to toggle cell
        let isPanning = false;
        let hasMoved = false;
        let isDragMode = false; // Space key pressed
        let startPoint = { x: 0, y: 0 };
        let startClientPoint = { x: 0, y: 0 };
        let startViewBox = { x: 0, y: 0 };

        // Toggle drag mode with Space key
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !isDragMode) {
                isDragMode = true;
                svg.style.cursor = 'grab';
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                isDragMode = false;
                svg.style.cursor = 'crosshair';
            }
        });

        svg.addEventListener('mousedown', (e) => {
            isPanning = true;
            hasMoved = false;
            const point = svg.createSVGPoint();
            point.x = e.clientX;
            point.y = e.clientY;
            const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());
            startPoint = { x: svgPoint.x, y: svgPoint.y };
            startClientPoint = { x: e.clientX, y: e.clientY };
            const viewBox = svg.viewBox.baseVal;
            startViewBox = { x: viewBox.x, y: viewBox.y };

            if (isDragMode) {
                svg.style.cursor = 'grabbing';
            }
        });

        svg.addEventListener('mousemove', (e) => {
            if (!isPanning) return;

            // Check if mouse has moved significantly (more than 3 pixels)
            const dx = e.clientX - startClientPoint.x;
            const dy = e.clientY - startClientPoint.y;
            if (Math.abs(dx) > 3 || Math.abs(dy) > 3) {
                hasMoved = true;
            }

            if (hasMoved && isDragMode) {
                const point = svg.createSVGPoint();
                point.x = e.clientX;
                point.y = e.clientY;
                const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());

                const svgDx = svgPoint.x - startPoint.x;
                const svgDy = svgPoint.y - startPoint.y;

                const viewBox = svg.viewBox.baseVal;
                svg.setAttribute('viewBox', `${startViewBox.x - svgDx} ${startViewBox.y - svgDy} ${viewBox.width} ${viewBox.height}`);
            }
        });

        svg.addEventListener('mouseup', (e) => {
            if (isPanning && !hasMoved) {
                // This is a click, not a drag
                const point = svg.createSVGPoint();
                point.x = e.clientX;
                point.y = e.clientY;
                const svgPoint = point.matrixTransform(svg.getScreenCTM().inverse());

                // Get cell at this point and toggle it (å…è®¸çŸ©å½¢å¤–çš„ç‚¹å‡»)
                const cellInfo = getCellAtPoint(svgPoint.x, svgPoint.y);
                if (cellInfo) {
                    toggleCell(cellInfo);
                }
            }

            isPanning = false;
            hasMoved = false;
            svg.style.cursor = isDragMode ? 'grab' : 'crosshair';
        });

        svg.addEventListener('mouseleave', () => {
            isPanning = false;
            hasMoved = false;
        });

        // Set initial cursor
        svg.style.cursor = 'crosshair';

        // Keyboard shortcuts for undo/redo
        document.addEventListener('keydown', (e) => {
            // Check for Ctrl (Windows/Linux) or Cmd (Mac)
            const modifier = e.ctrlKey || e.metaKey;

            if (modifier && e.key === 'z' && !e.shiftKey) {
                // Ctrl+Z or Cmd+Z: Undo
                e.preventDefault();
                undo();
            } else if (modifier && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                // Ctrl+Y or Cmd+Shift+Z: Redo
                e.preventDefault();
                redo();
            }
        });
    </script>
</body>
</html>
